# 计算机课程笔记：列表 (续)、循环节与插入排序

## 〇、课程概要与复习

- 本节课承接之前列表的内容，主要讲解两个核心概念：​**循环节 (Cycle Section)​**​ 和 ​**插入排序 (Insertion Sort)​**。
    
- 课前内容（如列表前序知识）请自行回顾，本节课不进行复习。
    

---

## 一、循环节 (Cycle Section)

### 1. 概念定义与辨析

- ​**引入背景：​**​ "循环节" 的概念是在列表章节中，讲解 ​**选择排序 (Selection Sort)​**​ 时被引入的。
    
- ​**核心辨析：​**​ 循环节是一个**客观独立**的概念，它可以**脱离选择排序**，甚至**脱离排序算法本身**来讨论。
    
    - ​**警告：​**​ 切勿将 "循环节" 与 "选择排序" 进行强行绑定或锁死。
        
    - ​**实例：​**​ 在往年真题中，循环节的概念也曾在**插入排序 (Insertion Sort)​**​ 的相关题目中出现过。
        
    
- ​**形式化定义 (PPT)：​**​ * 给定一个序列 S，对于任意元素 Ak​，其所属的循环节被定义为 k,r(k),r(r(k)),...。
    
    - r(k)指的是元素 Ak​在 S中对应的**秩 (rank)​**​（即 Ak​在 S的有序版本中的位置）。
        
    - 这个序列最终必然会返回到 k。
        
    - _讲师注：_这个基于 "秩" (PPT中称为 "字") 的定义比较绕口，且容易混淆元素和秩。
        
    

### 2. 循环节的直观理解与求解 (元素法)

> [!NOTE] 讲师推荐方法
> 
> 为了避免混淆，我们不使用 "秩 (rank)"，而是直接使用 "元素" 本身来描述和寻找循环节。

​**求解步骤：​**​

1. 准备两个序列：原始序列 A和 A的**有序版本**​ S。
    
2. 从 A中任选一个尚未被访问的元素 (如 A[i]) 开始。
    
3. 在 S中找到该元素 (A[i]) 的位置 (假设为 S[j])。
    
4. A[j]就是 A[i]在循环节中的 "下一个" 元素。
    
5. 重复步骤 3 和 4，直到 "下一个" 元素是最初开始的元素，形成闭环。
    

---

​**示例 1：​**​

- 原始序列 A=[2,1,4,5,3]
    
- 有序序列 S=[1,2,3,4,5]
    

1. ​**从 2 开始：​**​
    
    - 在 S中找到 ​**2**，其索引为 1。
        
    - 查看 A[1]，是 ​**1**。 (2 的下一个是 1)
        
    - 在 S中找到 ​**1**，其索引为 0。
        
    - 查看 A[0]，是 ​**2**。 (1 的下一个是 2)
        
    - ​**循环节 1：(2, 1)​**​
        
    
2. ​**从 4 开始 (2 和 1 已访问)：​**​
    
    - 在 S中找到 ​**4**，其索引为 3。
        
    - 查看 A[3]，是 ​**5**。 (4 的下一个是 5)
        
    - 在 S中找到 ​**5**，其索引为 4。
        
    - 查看 A[4]，是 ​**3**。 (5 的下一个是 3)
        
    - 在 S中找到 ​**3**，其索引为 2。
        
    - 查看 A[2]，是 ​**4**。 (3 的下一个是 4)
        
    - ​**循环节 2：(4, 5, 3)​**​
        
    

- ​**结论：​**​ 序列 `[2, 1, 4, 5, 3]`共有 2 个循环节。
    

​**示例 2：​**​

- 原始序列 A=[4,6,3,2,7,1,5]
    
- 有序序列 S=[1,2,3,4,5,6,7]
    

1. ​**从 4 开始：​**​
    
    - (4 →S[3]→A[3]→​**2**)
        
    - (2 →S[1]→A[1]→​**6**)
        
    - (6 →S[5]→A[5]→​**1**)
        
    - (1 →S[0]→A[0]→​**4**)
        
    - ​**循环节 1：(4, 2, 6, 1)​**​
        
    
2. ​**从 3 开始：​**​
    
    - (3 →S[2]→A[2]→​**3**)
        
    - ​**循环节 2：(3)​**​ (自成一个循环节)
        
    
3. ​**从 7 开始：​**​
    
    - (7 →S[6]→A[6]→​**5**)
        
    - (5 →S[4]→A[4]→​**7**)
        
    - ​**循环节 3：(7, 5)​**​
        
    

- ​**结论：​**​ 序列 `[4, 6, 3, 2, 7, 1, 5]`共有 3 个循环节。
    

> [!WARNING] 关于 PPT 示例的说明
> 
> 讲师指出，PPT 上关于 `G, C, P, E, A`的示例图示是**混乱的**。PPT 是按照 A序列中的**物理位置**来展示的，​**而不是**按照循环节的**逻辑顺序**。例如，按循环节定义，G 的下一个元素应是 C (因为 G 在 S中的位置对应 A中的 C)，而不是 PPT 上画的 P。请同学们按照讲师演示的方法来理解。

### 3. 循环节的性质

1. ​**必然闭环：​**​ 从任意元素出发，沿循环节寻找，最终必然会回到该元素本身。
    
2. ​**长度限制：​**​ 任意循环节的长度必然 ≤n(n为序列总长)。
    
3. ​**互不相交：​**​ 不同的循环节之间**互不相交**。
    
    - ​**原因：​**​ 循环节中，一个元素的 "下一个" 元素是**唯一确定**的。如果两个循环节有一个公共元素，它们必然完全重合，即为同一个循环节。
        
    

### 4. 循环节与选择排序 (交换法)

- ​**背景：​**​ 讨论选择排序的**交换法**​ (Exchange Method) 实现 (即每趟找到最大/最小元，与当前区间的末尾元素交换)。
    
- ​**交换的影响：​**​ 当一个元素 m(在第 i趟中) 被**实际交换**到其最终排好序的位置时：
    
    1. 元素 m​**脱离**其原来所属的循环节。
        
    2. 元素 m​**自成一个**新的、长度为 1 的循环节。
        
    3. m​**原所属**的循环节长度**恰好减少 1**。
        
    4. 序列的**循环节总个数增加 1**。
        
    
- ​**示例：​**​
    
    - A=[3,1,2]，S=[1,2,3]。
        
    - ​**排序前：​**​ 循环节为 (3 →2 →1 →3)。​**总个数 = 1**。
        
    - ​**第一趟 (交换法)：​**​ 找到 3 (最大值)，与末尾的 2 交换。
        
    - A变为 [2,1,3]。
        
    - ​**排序后 (状态)：​**​
        
        - 检查 3：已就位。循环节 (3)。
            
        - 检查 2：2 →S[1]→A[1]→1；1 →S[0]→A[0]→2。循环节 (2, 1)。
            
        
    - ​**结论：​**​ 循环节变为 (3) 和 (2, 1)。​**总个数 = 2**。原循环节 (3, 2, 1) 变为 (2, 1)，3 脱离。
        
    

### 5. 多余的交换 (习题 3-13 & 3-14)

- ​**定义：​**​ "多余的交换" (或 "无需交换") 指在选择排序中，当前 A[m]恰好就是 A[0...m]中的最大/最小元，它**已经就位**​ (in-place)。
    
- ​**代码表现：​**​ 表现为 "自己和自己交换"，操作被浪费。
    
- ​**发生次数 (习题 3-13)：​**​
    
    - ​**结论：​**​ 如果序列初始有 C个循环节，则在 n−1趟选择排序中，"多余交换" 的总次数**恰好为 C次**。
        
    - ​**推导：​**​
        
        1. 排序完成时，序列变为全有序 (如 S=[1,2,3,...,n])。
            
        2. 此时，​**每个元素都自成一个循环节**​ (1 →1, 2 →2...)。
            
        3. 因此，排序完成时，循环节**总个数为 n​**。
            
        4. 初始有 C个，最终有 n个。
            
        5. 每一次**实际的**交换，会使循环节总数 +1。
            
        6. 要从 C变为 n，需要 n−C次**实际交换**。
            
        7. 总共 n−1趟排序，故 "多余交换" (即不发生实际交换) 的次数为 (n−1)−(n−C)... (※讲师此处口误，应为：总共 n个元素，需要 n−C次交换才能使 n个元素全部就位，剩下的 C个元素在轮到它们时，无需交换)。
            
            - _修正后的逻辑：_排序过程共 n轮 (或 n−1轮)，总共需要 n−C次实际交换才能将 C个循环节拆成 n个单元素循环节。因此，"无需交换" (多余交换) 的次数就是 C次。
                
            
        
    
- ​**​"优化" 讨论 (习题 3-14)：​**​
    
    - ​**想法：​**​ 能否通过加一个 `if`判断，来跳过 "多余交换"？
        
    - ​**分析：​**​ 这种 "优化" 是否值得，取决于 "多余交换" 发生的**期望次数**。如果期望次数很少，那么在每一轮都增加一次 `if`判断的开销是**得不偿失**的。
        
    - ​**期望次数 (3-14b)：​**​ 在各元素等概率分布下，"多余交换" 发生的**期望次数为 O(lnn)​**​ (自然对数)。
        
    - ​**推导 (3-14b)：​**​
        
        1. 在第 m趟迭代时，发生 "多余交换" 的充要条件是 A[m]恰好是 A[0...m](共 m+1个元素) 中的最大元素。
            
        2. 在独立均匀分布下，此事件发生的概率为 m+11​(或 m1​，取决于索引)。
            
        3. 根据期望的线性率，总的期望次数为 ∑m=1n​m1​。
            
        4. 这个和是**调和级数 (Harmonic Series)​**，其渐进复杂度等于 O(lnn)。
            
        
    - ​**结论：​**​ "多余交换" 发生的期望次数 O(lnn)非常少。为了节省这 O(lnn)次交换，而在 n−1趟中**每次**都增加 `if`判断的开销 (O(1))，在渐进意义上是**得不偿失**的。
        
    

> [!NOTE] 讲师强调 (习题 3-14b)
> 
> 证明 "优化" 得不偿失 (即证明期望次数为 O(lnn)) 的过程，​**完全可以脱离循环节的概念**。习题 3-14a 只是介绍了循环节，但 3-14b 的证明 (如上所述) 是独立的。

---

## 二、插入排序 (Insertion Sort)

### 1. 算法原理与图示

- ​**适用性：​**​ 插入排序可以基于向量 (Array) 实现，也可以基于列表 (List) 实现。
    
- ​**核心思想：​**​ 始终将序列视作两个部分：
    
    1. ​**有序前缀区 (Sorted Prefix)​**​
        
    2. ​**待排后缀区 (Unsorted Suffix)​**​
        
    
- ​**算法流程：​**​ 反复从 "待排后缀区" 取出第一个元素，在 "有序前缀区" 中找到合适的位置并**插入**。
    
- ​**示例：​**​ `[5, 2, 7, 4, 6, 3, 1]`
    
    1. `[5]`| `[2, 7, 4, 6, 3, 1]`(5 插入)
        
    2. `[2, 5]`| `[7, 4, 6, 3, 1]`(2 插入到 5 前面)
        
    3. `[2, 5, 7]`| `[4, 6, 3, 1]`(7 插入到 5 后面)
        
    4. `[2, 4, 5, 7]`| `[6, 3, 1]`(4 插入到 2 和 5 之间)
        
    5. `[2, 4, 5, 6, 7]`| `[3, 1]`(6 插入到 5 和 7 之间)
        
    6. `[2, 3, 4, 5, 6, 7]`| `[1]`(3 插入到 2 和 4 之间)
        
    7. `[1, 2, 3, 4, 5, 6, 7]`| `[]`(1 插入到 2 前面)
        
    
- ​**查找方向：​**​ 在 "有序前缀区" 查找插入位置时，标准实现是**从右向左**​ (即从后向前) 比较。
    

### 2. 复杂度分析

- ​**最好情况： O(n)​**​
    
    - 当序列**完全有序**时 (如 `[1, 2, 3, 4, 5, 6, 7]`)。
        
    - 每次从后缀区拿到的元素，都比有序区末尾的元素大，只需比较 1 次，无需移动，直接追加到有序区末尾。
        
    
- ​**最坏情况： O(n2)​**​
    
    - 当序列**完全逆序**时 (如 `[7, 6, 5, 4, 3, 2, 1]`)。
        
    - 每次拿到的元素都是当前最小的，需要**从右到左**比较完所有有序区的元素，并插入到最前端。
        
    

> [!WARNING] 讲师批注：不要 "开上帝视角"
> 
> - 有同学可能会 "抬杠"：如果我知道是完全逆序，我**从左向右**比较，是不是就是 O(n)了？
>     
> - ​**反驳：​**​ 算法在执行前**无法预知**输入数据的分布。
>     
> - 如果你强行改成 "从左向右" 比较，那么对于**完全有序**​ (即最好情况) 的输入 (如 `[1, 2, 3, 4]`)，反而会**退化**成 O(n2)(如插入 4 时，需要和 1, 2, 3 依次比较)。
>     
> - 不能根据输入来"双重标准"地选择算法实现。
>     

### 3. 折半插入排序 (Binary Insertion Sort)

- ​**提问：​**​ 既然有序前缀区是 "有序" 的，为什么不用 O(logn)的**二分查找 (Binary Search)​**​ 来代替 O(n)的线性查找？
    
- ​**分析 (基于列表)：​**​
    
    - 如果使用**链表**，二分查找本身就是低效的。仅 "找到" 中间那个元素，就需要 O(n)的时间 (因为无法随机访问)。
        
    
- ​**分析 (基于向量)：​**​
    
    - 使用**向量 (数组)​**，"查找" 插入位置确实可以优化到 O(logn)。
        
    - ​**但是：​**​ 插入排序的主要开销在于**元素的移动 (Movement)​**。
        
    - 找到位置后，为了插入元素 (如在 3 和 4 之间插入 3.5)，需要将 4 之后的所有元素**集体向后平移一位**。
        
    - 在最坏/平均情况下，这个 "移动" 操作的开销是 O(n)。
        
    - ​**结论：​**​ 算法总复杂度仍然是 O(n2)，没有实质性优化。
        
    
- ​**折半插入排序的复杂度 (总结)：​**​
    
    - ​**最坏情况： O(n2)​**​ (查找 O(logn)+ 移动 O(n)，共 n轮)
        
    - ​**最好情况： O(nlogn)​**​
        
        - ​**反向优化：​**​ 折半插入排序**反而使最好情况变差了**。
            
        - ​**对比 (最好情况)：​**​
            
            - ​**普通插入排序：​**​ `[1, 2, 3, 4, 5, 6]`| `[7]`。插入 7，只需和 6 比较 1 次 (O(1))。总时间 O(n)。
                
            - ​**折半插入排序：​**​ `[1, 2, 3, 4, 5, 6]`| `[7]`。插入 7，需要对 `[1...6]`进行**二分查找**来确定 7 应该在 6 之后。此查找耗时 O(logn)。总时间 O(nlogn)。
                
            
        
    

### 4. 插入排序与 "无需移动" (习题 3-10c)

- ​**讨论 (习题 3-10c)：​**​ "序列的插入排序过程中，平均有多少个元素无需移动？"
    
- ​**书本解答逻辑：​**​ 书上的解答推导了 "待插入元素 Ak​恰好是 A[0...k]中最大元素" 的期望次数，这个次数是 O(lnn)。
    
- ​**讲师 critique (问题不严谨)：​**​
    
    - "无需移动" (无需移动) 这个词有歧义，取决于底层实现 (向量 vs 列表)。
        
    - ​**场景 (向量 Vector)：​**​
        
        - 序列 `[1, 2, 4]`| `[3]`。
            
        - 在处理 `[1, 2, 4]`时，4 是 A[0...2]中的最大值。按书本逻辑，此时 4 "无需移动"。
            
        - ​**但是**，在下一步插入 3 时，序列变为 `[1, 2, 3, 4]`。
            
        - 为了给 3 腾出空间，元素 4 ​**必须向右移动**。
            
        - ​**结论 (向量)：​**​ 元素在 "插入时" 无需移动，不代表它在 "整个算法过程中" 无需移动。因此，用向量实现时，书本的解答 (O(lnn)) ​**是错误的**​ (或至少答非所问)。
            
        
    - ​**场景 (列表 List)：​**​
        
        - 如果用链表实现，插入 3 只是在 2 和 4 之间修改指针。节点 4 本身并未 "移动"。
            
        - ​**结论 (列表)：​**​ 在列表实现下，书本的 O(lnn)解答是合理的。
            
        
    - ​**总结：​**​ 该习题 (3-10c) 没有指明是基于向量还是列表，导致表述**不严谨**。
        
    

### 5. 算法特性：输入敏感 (Input-Sensitive)

- ​**定义：​**​ 插入排序的效率**高度依赖于输入数据**的初始状态。
    
    - O(n)(已排序) →O(n2)(逆序)。
        
    
- ​**度量 "乱序"：​**​ 如何度量一个序列的乱序程度？
    
    - ​**方法：​**​ ​**逆序对 (Inversions)​**​ 的数量。
        
    - ​**定义：​**​ 逆序对指序列中满足 i<j但 A[i]>A[j]的元素对 (A[i],A[j])。
        
    
- ​**习题 3-11：​**​ 插入排序的运行时间与逆序对的数量和 "间距" (Distance) 相关。若所有逆序对的间距均不超过 k，则运行时间为 O(kn)。
    

---

## 三、课后习题解析 (随堂练习)

​**练习 1：​**​

> 对于插入排序过程中，已排子序列 (设长度为 k) ...
> 
> (A) 其中的元素是整个序列当中最小的 k个元素
> 
> (B) 其中的元素是整个序列当中最大的 k个元素
> 
> (C) 其中的元素是原序列中位于前方的 k个元素

- ​**分析：​**​
    
    - (A) 错误。例：`[3, 2, 1]`，第一步排序后，有序区为 `[2, 3]`，待排区 `[1]`。`[2, 3]`并不是最小的两个元素。
        
    - (B) 错误。例：`[1, 2, 3]`，第一步排序后，有序区为 `[1, 2]`，待排区 `[3]`。`[1, 2]`并不是最大的两个元素。
        
    - (C) 正确。插入排序是 "就地" (in-place) 的，它只是将**原序列**的前 k个元素进行了排序，构成了有序区。
        
    
- ​**答案：C**​
    

​**练习 2：​**​

> 此时已排序的部分有 3 个元素 [2,7,13]，待排序的部分是 [5,3]。经过一轮迭代后，已排序的部分是？

- ​**分析：​**​
    
    - 下一轮迭代是取出待排区的第一个元素 ​**5**。
        
    - 将 5 插入到有序区 `[2, 7, 13]`中。
        
    - 从右向左比较：5 < 13，5 < 7，5 > 2。
        
    - 5 被插入到 2 和 7 之间。
        
    
- ​**答案：(C) [2,5,7,13]​**