[[折半插入排序]]

[[直接插入排序]]

[[希尔排序]]

### 算法原理与图示

- ​**适用性：​**​ 插入排序可以基于向量 (Array) 实现，也可以基于列表 (List) 实现。
    
- ​**核心思想：​**​ 始终将序列视作两个部分：
    
    1. ​**有序前缀区 (Sorted Prefix)​**​
        
    2. ​**待排后缀区 (Unsorted Suffix)​**​
        
    
- ​**算法流程：​**​ 反复从"待排后缀区"取出第一个元素，在"有序前缀区"中找到合适的位置并**插入**。
    

### 查找方向与复杂度分析

- ​**查找方向：​**​ 在"有序前缀区"查找插入位置时，标准实现是**从右向左**比较。
    
- ​**最好情况：O(n)​**​
    
    - 当序列**完全有序**时
        
    
- ​**最坏情况：O(n2)​**​
    
    - 当序列**完全逆序**时
        
    
###  插入排序与 "无需移动" (习题 3-10c)

- ​**讨论 (习题 3-10c)：​**​ "序列的插入排序过程中，平均有多少个元素无需移动？"
    
- ​**书本解答逻辑：​**​ 书上的解答推导了 "待插入元素 Ak​恰好是 A[0...k]中最大元素" 的期望次数，这个次数是 O(lnn)。
    
- ​**讲师 critique (问题不严谨)：​**​
    
    - "无需移动" (无需移动) 这个词有歧义，取决于底层实现 (向量 vs 列表)。
        
    - ​**场景 (向量 Vector)：​**​
        
        - 序列 `[1, 2, 4]`| `[3]`。
            
        - 在处理 `[1, 2, 4]`时，4 是 A[0...2]中的最大值。按书本逻辑，此时 4 "无需移动"。
            
        - ​**但是**，在下一步插入 3 时，序列变为 `[1, 2, 3, 4]`。
            
        - 为了给 3 腾出空间，元素 4 ​**必须向右移动**。
            
        - ​**结论 (向量)：​**​ 元素在 "插入时" 无需移动，不代表它在 "整个算法过程中" 无需移动。因此，用向量实现时，书本的解答 (O(lnn)) ​**是错误的**​ (或至少答非所问)。
            
        
    - ​**场景 (列表 List)：​**​
        
        - 如果用链表实现，插入 3 只是在 2 和 4 之间修改指针。节点 4 本身并未 "移动"。
            
        - ​**结论 (列表)：​**​ 在列表实现下，书本的 O(lnn)解答是合理的。
            
        
    - ​**总结：​**​ 该习题 (3-10c) 没有指明是基于向量还是列表，导致表述**不严谨**。
        
    

### 5. 算法特性：输入敏感 (Input-Sensitive)

- ​**定义：​**​ 插入排序的效率**高度依赖于输入数据**的初始状态。
    
    - O(n)(已排序) →O(n2)(逆序)。
        
    
- ​**度量 "乱序"：​**​ 如何度量一个序列的乱序程度？
    
    - ​**方法：​**​ ​**逆序对 (Inversions)​**​ 的数量。
        
    - ​**定义：​**​ 逆序对指序列中满足 i<j但 A[i]>A[j]的元素对 (A[i],A[j])。
        
    
- ​**习题 3-11：​**​ 插入排序的运行时间与逆序对的数量和 "间距" (Distance) 相关。若所有逆序对的间距均不超过 k，则运行时间为 O(kn)。