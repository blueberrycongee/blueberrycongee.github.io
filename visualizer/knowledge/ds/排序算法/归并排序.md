
## II. 归并排序 (Merge Sort)

### 1. 核心思想与背景

- ​**核心思想：​**​ ​**分而治之（Divide and Conquer）​**。
    
- ​**通用性：​**​ 适用于向量（数组）和列表等序列结构。
    
- ​**历史：​**​ 1945年由冯·诺依曼（Von Neumann）首次编程实现。
    
- ​**优势：​**​ 在基于比较（Comparison-Based，CBA）的排序算法中，从渐进时间复杂度意义上讲，它能将时间复杂度压到最低的 O(nlogn)。
    

### 2. 算法步骤 (递归实现)

1. ​**划分（Divide）：​**​ 将序列一分为二，找到中间位置 `mid`，划分成左右两个子序列。
    
    - 时间复杂度：O(1)（向量中只需计算中点索引）。
        
    
2. ​**递归排序（Recur）：​**​ 递归地对左、右两个子序列进行归并排序。
    
3. ​**合并（Combine/Merge）：​**​ 将两个已经有序的子序列合并（Merge）成一个完整的有序序列。
    
    - 时间复杂度：O(n)。
        
    

### 3. 合并（Merge）操作细节

- ​**操作：​**​ 二路归并（Two-Way Merge），将两个有序子序列合二为一，并保持最终序列有序。
    
- ​**思路（双指针）：​**​ 比较两个子序列的当前最小值（指针指向的元素）。
    
    - 将较小的元素取出并放入最终的合并序列中。
        
    - 对应的指针后移。
        
    - 重复此过程，直到其中一个子序列耗尽。
        
    - 将未耗尽的子序列中剩余元素依次放入合并序列。
        
    
- ​**实现要点：​**​ 需要申请一个**辅助空间**​（对等规模 O(n)）来存放两个子序列，并进行复制操作，以便原地合并到原数组的对应区间。
    

### 4. 时间复杂度分析

- ​**递推关系式：​**​ 算法的运行时间成本 T(n)满足 T(n)=2T(n/2)+O(n)。
    
    - 2T(n/2)：递归排序两个 n/2规模的子序列。
        
    - O(n)：合并（Merge）两个有序子序列的时间成本。
        
    
- ​**最终复杂度：​**​ 根据主定理，整体运行时间成本为 ​**​O(nlogn)​**。
    [[主定理]]
- ​**注意：​**​ 无论子序列的长度是否相等或相差悬殊，合并操作的时间复杂度都为 O(n)。
    

### 5. 归并排序的综合评价

#### 5.1 优点 (实现最坏情况下的最优)

- ​**渐进最优：​**​ 在基于比较（CBA）的排序算法中，实现了最坏情况下 O(nlogn)的最优时间复杂度。
    
- ​**访问模式：​**​ 不需要随机读写，完全是**顺序访问**。
    
    - ​**适用性：​**​ 特别适用于列表（链表）和磁带之类的顺序存取设备。
        
    
- ​**稳定性：​**​ ​**实现恰当可以保证稳定**。
    
    - ​**稳定实现：​**​ 在合并（Merge）操作中，当比较到相等的元素时，应采用 ​**小于等于（B[i]≤C[k]）​**​ 的条件，确保左侧子向量的元素优先进入合并序列，从而保持相对次序。
        
    
- ​**可拓展性：​**​ 极佳，非常适合**外部排序**​（数据量大于内存容量）。
    
- ​**并行化：​**​ ​**易于并行化**。因为划分是独立的，可以在多个处理器上同时对不同的子序列进行排序（如将 32GB 数据分成 8 份在 8 台电脑上排序）。
    

#### 5.2 缺点

- ​**非原地（Non-In-Place）：​**​ 需要一个对等规模的**辅助空间**。
    
    - ​**空间复杂度：​**​ O(n)。这是其主要缺点。
        
    - ※ ​**待解决问题：​**​ 是否能节省空间（有节省空间的实现版本，留作课后思考）。
        
    
- ​**有序性不敏感：​**​ 即便输入序列**已经完全有序**或接近有序，算法的时间复杂度仍然是 O(nlogn)。
    
    - ​**原因：​**​ 算法的划分和递归过程依然会执行，且合并（Merge）操作仍需 O(n)时间（例如，比较 1,2,3,4和 5,6,7,8时，1,2,3,4仍需分别与 5比较一次）。
        
    

#### 5.3 针对缺点的改进

- ​**目标：​**​ 解决有序性不敏感的问题，使最好情况复杂度降至 O(n)。
    
- ​**改进方案（习题解析 2-27）：​**​ 在即将调用归并（Merge）接口之前，先进行一次**判断**。
    
- ​**判断条件：​**​ 检查左子向量的末尾元素是否小于或等于右子向量的起始元素。
    
    If A[mid−1]≤A[mid]
    
    - 如果此条件成立，则说明左右两个已排序的子序列整体上已经有序，​**无需执行合并操作**。
        
    
- ​**效果：​**​
    
    - ​**最好情况：​**​ 如果序列完全有序，则可以在 O(1)（单次判断）的时间成本下，避免 O(n)的合并操作，将整个算法的最好时间复杂度降至 O(n)。
        
    - ​**渐进时间复杂度：​**​ 并没有改变，仍是 O(nlogn)。
        
    
- ​**重要前提（注意）：​**​
    
    - ​**非默认优化：​**​ 此优化并非默认写法，它是有前提的。
        
    - ​**应用场景：​**​ 仅适用于输入数据**有序性较好**​（即很有可能出现 A[mid−1]≤A[mid]的情况，如学号排序、预排序数据）的场景。
        
    - ​**随机数据：​**​ 如果数据是随机的，加上此 `if`判断反而会增加常系数（3.0变成 3.1等），是一种**劣化**。
        
    

---

## III. 扩展：查找算法比较（课后习题回顾）

### 二分查找版本A与版本B的最好时间复杂度

|算法版本|最好情况时间复杂度|逻辑分析|
|---|---|---|
|​**版本 A**​|O(1)|版本A的 `while`循环内部包含 `if (命中)`则直接 `return`的逻辑。最好的情况下，要找的元素刚好在第一次比较时命中，比较次数很少（如 2 次），时间复杂度为 O(1)。|
|​**版本 B**​|O(logn)|版本B的查找逻辑是不断二分缩小范围，​**直到问题规模缩减到 1 时才跳出循环**。退出循环后才进行最终的判断和 `return`。因此，即使元素是第一个，也需要 O(logn)次比较才能达到退出循环的条件。|
|​**平均情况**​|O(logn)|两个版本在渐进时间复杂度意义上（包括平均和最坏）均为 O(logn)。区别在于常系数（如一个 1.5logn，一个 1.0logn）和最好情况下的行为。|
## 🎯 知识点总结与回顾

### 1. 归并排序（Merge Sort）的空间复杂度优化问题

- ​**问题回顾：​**​ 上次课提到归并排序所需的**辅助空间（辅助数组）​**能否进行优化。
    
- ​**优化结论：​**​ 归并排序的辅助空间**可以优化**。
    
    - ​**归并（Merge）操作本身的空间复杂度：​**​ 可以实现 O(1)的空间复杂度。
        
        - ​**注意：​**​ 优化方法可能会使用到乘法和除法等运算，虽然节省了空间，但可能导致**时间复杂度常系数**增大。
            
        - 这属于"用**时间换空间**​"的策略，通常倾向于"用空间换时间"。在空间资源极度不足时，可考虑此方法。
            
        
    - ​**归并排序（Merge Sort）整体的空间复杂度：​**​ 即使归并操作本身的空间复杂度是 O(1)，​**归并排序整体的空间复杂度也**不是 O(1)。
        
        - ​**原因：​**​ 递归实现的归并排序存在**递归调用栈**，需要额外的辅助空间。
            
        - ​**结论：​**​ 宣称 O(1)空间的归并排序是不准确的，除非是**迭代版本**。
            
        
    
- ​**迭代版归并排序（Iterative Merge Sort）：​**​
    
    - ​**思路：​**​ 迭代版本将递归（置顶向下）的思路**逆转**为**自底向上**。
        
    - ​**过程：​**​
        
        1. 从单个元素（有序子向量）开始。
            
        2. 进行**两两归并**。
            
        3. 逐渐将两个 2 元素的向量归并成一个 4 元素的向量，依此类推。
            
        
    - ​**转化技巧：​**​ 递归改迭代是重要的基本功，例如斐波那契数列（Fibonacci Sequence）的第 n个数求解和最长公共子序列（LCS）问题，都可以从递归转化为迭代。
        
    
