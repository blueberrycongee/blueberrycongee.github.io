# 向量排序算法笔记

## I. 起泡排序 (Bubble Sort)

### 1. 核心思路与过程

- ​**基本原理：​**​ 依次比较相邻元素，如果它们是“逆序”（逆序：前面的元素大于后面的元素），则交换它们的位置。
    
- ​**终止条件：​**​ 直到某趟扫描后，确认所有相邻元素均已是“顺序”（有序）排列，即没有发生任何交换时，算法终止。
    
- ​**逆序与顺序：​**​
    
    - ​**有序序列：​**​ 任何一对相邻元素都是顺序的。
        
    - ​**无序序列：​**​ 总存在至少一对相邻元素是逆序的。
        
    
- ​**单趟扫描效果（“就位”/“归位”概念）：​**​
    
    - ​**就位（归位）：​**​ 元素到达其最终在完全排序序列中的位置。
        
    - 经过 k趟扫描交换后，最大的 k个元素必然就位。
        
    - 经过一趟扫描，当前未排序部分的最大元素会移动到其最终就位的位置（当前未排序部分的末尾）。
        
    - 问题规模（未排序区间）每趟会缩减一个元素，经过 n−1趟扫描交换，问题规模缩减至 n−(n−1)=1，算法必然终止，所有元素就位。
        
    

### 2. 基本版算法实现

- ​**趟数（外层循环）：​**​ 最多进行 n−1趟扫描。
    
- ​**比较与交换（内层循环）：​**​ 每次扫描中，使用一个 `if`语句判断 A[i]是否大于 A[i+1]。
    
- ​**交换逻辑：​**​ 如果 A[i]>A[i+1]（逆序），则交换两者的值。
    
- ​**实现结构：​**​ 嵌套的两层循环，外层控制趟数（`high`不断减小），内层进行相邻元素比较和交换。
    

### 3. 算法优化与改进（早停/跳跃版）

#### 3.1 优化一：提前终止（早停机制）

- ​**问题：​**​ 基本版即使输入序列一开始就有序，仍需扫描 n−1趟（尽管没有交换），造成浪费。
    
- ​**优化方案：​**​ 引入一个布尔变量（标志），假设序列已排序完成。
    
- ​**终止判断：​**​ 如果某一趟扫描中**没有发生任何交换**，则说明序列已完全有序，算法可以提前终止。
    

#### 3.2 优化二：跳跃版（缩减扫描范围）

- ​**改进目标：​**​ 加快排序过程，尤其当某一段后缀已经有序时。
    
- ​**核心思想：​**​ 记录上一趟扫描中最后一次发生交换的位置 `last`。
    
- ​**范围缩减：​**​ 在 `last`之后的元素（即 [last+1,high]区间）已确定有序。下一趟扫描的结束位置（`high`）可以直接更新为 `last`，而不是简单地 high−1。
    
- ​**问题规模：​**​ 相当于快速缩减了问题规模。
    
- ​**复杂度注意：​**​ 即使是这个优化后的跳跃版，其**平均时间复杂度**和**最坏时间复杂度**仍然是 O(n²)。
    

### 4. 时间复杂度分析

|情况|时间复杂度|说明|
|---|---|---|
|​**最好情况**​|O(n)|输入序列完全有序，仅需一趟扫描（通过优化一的判断）发现没有逆序和交换，即可终止。|
|​**最坏情况**​|O(n2)|输入序列完全逆序，需要进行 O(n2)次比较和交换。|
|​**平均情况**​|O(n2)|考虑所有 n个数的全排列情况，求平均时间复杂度仍为 O(n2)。|

### 5. 排序算法的稳定性

- ​**定义：​**​ 排序算法的稳定性指在输入和输出序列中，​**相等元素**的相对次序保持不变。
    
- ​**作用：​**​ 有时需要追求稳定性，例如在多指标排序或有强迫症的情况下（如成绩排名）。
    
- ​**正确性与稳定性：​**​ 算法的正确性（能否完成排序）与稳定性是两个独立的概念，不稳定的算法不代表有缺陷。
    
- ​**起泡排序的稳定性：​**​
    
    - ​**结论：​**​ ​**起泡排序是稳定的**。
        
    - ​**原因：​**​ 算法的实现逻辑是 ​**大于（`>`）时才交换**。如果元素相等（A[i]=A[i+1]），则不发生交换，保持其相对次序不变。
        
    - ​**反面教材：​**​ 如果将比较条件改为 ​**大于等于（`>=`）​**，则算法会变得不稳定。
        
    - ​**注意：​**​ 在讨论排序算法稳定性时，应默认采用最自然的实现方式（起泡排序默认用 `>`），不应通过修改比较符（如改为 `>=`）来抬杠其不稳定性。
        
    



## 算法-起泡排序判断题

**日期**: 2025-10-21
**来源**: 算法与数据结构
#review错题本 #计算机科学/算法/排序

---

### 一、原题

> [!question] 判断题
> 2、起泡排序中存在某元素的起始位置与其最终位置相邻，甚至已经处于最终位置，却需要参与 $n-1$ 次交换的情况。
>
> **答案：对 (True)**

---

### 二、知识回顾：标准起泡排序（大数上浮）

为了分析此题，我们必须明确所使用的算法。标准起泡排序（大数上浮）的伪代码如下：

```pseudocode
def bubble_sort(A):
    n = len(A)
    for i from 0 to n-2:  // (n-1) 趟
        # 第 i 趟将第 i 大的数“冒泡”到 A[n-1-i]
        for j from 0 to n-2-i: 
            if A[j] > A[j+1]:
                swap(A[j], A[j+1])
                
                
```
### 三、"病态"实例解析

此命题为 **真**。我们可以构造一个特殊的序列来证明。

#### 1. “已经处于最终位置”的情况（以 $n=7$ 为例）

- 考察序列 (n=7):
    
    $$A = \{ 5, 6, 7, 4, 1, 2, 3 \}$$
    
- **目标元素**: `4`
    
- **起始位置**: `A[3]`
    
- **最终位置** (排序后 `{1,2,3,4,5,6,7}`)：`A[3]`
    
- **条件**: 满足“已经处于最终位置”。
    
- **目标**: 证明元素 `4` 参与了 $n-1 = 6$ 次交换。
    

**逐趟追踪元素 `4` 的交换过程：**

1. **第 1 趟 (i=0, j 从 0 到 5)**:
    
    - `[ 5, 6, 7, 4, 1, 2, 3 ]`
        
    - `j=0`: `5 > 6` (F)
        
    - `j=1`: `6 > 7` (F)
        
    - `j=2`: `7 > 4` (T) $\to$ **Swap(7, 4)**. 序列变为 `[ 5, 6, 4, 7, 1, 2, 3 ]`。
        
        - 元素 `4` **交换 1 次**，移动到 `A[2]`。
            
    - `j=3`: `7 > 1` (T) $\to$ Swap(7, 1)
        
    - `j=4`: `7 > 2` (T) $\to$ Swap(7, 2)
        
    - `j=5`: `7 > 3` (T) $\to$ Swap(7, 3)
        
    - _本趟结束_: `[ 5, 6, 4, 1, 2, 3, 7 ]`。`4` 位于 `A[2]`。
        
2. **第 2 趟 (i=1, j 从 0 到 4)**:
    
    - `[ 5, 6, 4, 1, 2, 3, 7 ]`
        
    - `j=0`: `5 > 6` (F)
        
    - `j=1`: `6 > 4` (T) $\to$ **Swap(6, 4)**. 序列变为 `[ 5, 4, 6, 1, 2, 3, 7 ]`。
        
        - 元素 `4` **交换 1 次**，移动到 `A[1]`。
            
    - ... (后续交换与 `4` 无关)
        
    - _本趟结束_: `[ 5, 4, 1, 2, 3, 6, 7 ]`。`4` 位于 `A[1]`。
        
3. **第 3 趟 (i=2, j 从 0 到 3)**:
    
    - `[ 5, 4, 1, 2, 3, 6, 7 ]`
        
    - `j=0`: `5 > 4` (T) $\to$ **Swap(5, 4)**. 序列变为 `[ 4, 5, 1, 2, 3, 6, 7 ]`。
        
        - 元素 `4` **交换 1 次**，移动到 `A[0]`。
            
    - ... (后续交换与 `4` 无关)
        
    - _本趟结束_: `[ 4, 1, 2, 3, 5, 6, 7 ]`。`4` 位于 `A[0]`。
        
4. **第 4 趟 (i=3, j 从 0 到 2)**:
    
    - `[ 4, 1, 2, 3, 5, 6, 7 ]`
        
    - `j=0`: `4 > 1` (T) $\to$ **Swap(4, 1)**. 序列变为 `[ 1, 4, 2, 3, ... ]`。
        
        - 元素 `4` **交换 1 次**，移动到 `A[1]`。
            
    - `j=1`: `4 > 2` (T) $\to$ **Swap(4, 2)**. 序列变为 `[ 1, 2, 4, 3, ... ]`。
        
        - 元素 `4` **交换 1 次**，移动到 `A[2]`。
            
    - `j=2`: `4 > 3` (T) $\to$ **Swap(4, 3)**. 序列变为 `[ 1, 2, 3, 4, ... ]`。
        
        - 元素 `4` **交换 1 次**，移动到 `A[3]`（最终位置）。
            
    - _本趟结束_: `[ 1, 2, 3, 4, 5, 6, 7 ]`。
        
5. **第 5 趟 (i=4)**: 无交换。
    
6. **第 6 趟 (i=5)**: 无交换。
    

**总交换次数统计 (for 元素 `4`)**:

- 第 1 趟: 1 次
    
- 第 2 趟: 1 次
    
- 第 3 趟: 1 次
    
- 第 4 趟: 3 次
    
- **总计**: $1 + 1 + 1 + 3 = 6$ 次。
    

由于 $n=7$，总交换次数 $6 = n-1$。命题得证。

---

#### 2. “起始与最终位置相邻”的情况（以 $n=6$ 为例）

- 考察序列 (n=6):
    
    $$A = \{ 5, 6, 4, 1, 2, 3 \}$$
    
- **目标元素**: `4`
    
- **起始位置**: `A[2]`
    
- **最终位置** (排序后 `{1,2,3,4,5,6}`)：`A[3]`
    
- **条件**: 满足“起始与最终位置相邻”。
    
- **目标**: 证明元素 `4` 参与了 $n-1 = 5$ 次交换。
    

**逐趟追踪元素 `4` 的交换过程：**

1. **第 1 趟 (i=0)**: `j=1` 时 `Swap(6, 4)`。 `4` 移动到 `A[1]`。 **(交换 1 次)**
    
    - _本趟结束_: `[ 5, 4, 1, 2, 3, 6 ]`
        
2. **第 2 趟 (i=1)**: `j=0` 时 `Swap(5, 4)`。 `4` 移动到 `A[0]`。 **(交换 1 次)**
    
    - _本趟结束_: `[ 4, 1, 2, 3, 5, 6 ]`
        
3. **第 3 趟 (i=2)**:
    
    - `j=0`: `Swap(4, 1)`。 `4` 移动到 `A[1]`。 **(交换 1 次)**
        
    - `j=1`: `Swap(4, 2)`。 `4` 移动到 `A[2]`。 **(交换 1 次)**
        
    - `j=2`: `Swap(4, 3)`。 `4` 移动到 `A[3]`。 **(交换 1 次)**
        
    - _本趟结束_: `[ 1, 2, 3, 4, 5, 6 ]`
        
4. **第 4、5 趟**: 无交换。
    

**总交换次数统计 (for 元素 `4`)**:

- 第 1 趟: 1 次
    
- 第 2 趟: 1 次
    
- 第 3 趟: 3 次
    
- **总计**: $1 + 1 + 3 = 5$ 次。
    

由于 $n=6$，总交换次数 $5 = n-1$。命题得证。

---

### 四、总结与反思

> [!summary] 结论
> 
> 1. 该命题为 **真**。
>     
> 2. 歧义已消除。命题确实是指**交换 (Swap)**，而非比较 (Compare)。
>     
> 3. 其成立的关键在于构造了一个特殊的序列，使得一个**本应不动或少动**的元素（如`4`），被它**左侧更大的元素**（如`5, 6, 7`）“挤”到了数组的前端。
>     
> 4. 随后，在后续的趟中，这个元素又被它**右侧更小的元素**（如`1, 2, 3`）“推”回其最终位置。
>     
> 5. 这个 "先左移，再右移" 的完整过程，使其总交换次数达到了 $n-1$ 次。
>