### 3. 折半插入排序 (Binary Insertion Sort)

- ​**提问：​**​ 既然有序前缀区是 "有序" 的，为什么不用 O(logn)的**二分查找 (Binary Search)​**​ 来代替 O(n)的线性查找？
    
- ​**分析 (基于列表)：​**​
    
    - 如果使用**链表**，二分查找本身就是低效的。仅 "找到" 中间那个元素，就需要 O(n)的时间 (因为无法随机访问)。
        
    
- ​**分析 (基于向量)：​**​
    
    - 使用**向量 (数组)​**，"查找" 插入位置确实可以优化到 O(logn)。
        
    - ​**但是：​**​ 插入排序的主要开销在于**元素的移动 (Movement)​**。
        
    - 找到位置后，为了插入元素 (如在 3 和 4 之间插入 3.5)，需要将 4 之后的所有元素**集体向后平移一位**。
        
    - 在最坏/平均情况下，这个 "移动" 操作的开销是 O(n)。
        
    - ​**结论：​**​ 算法总复杂度仍然是 O(n2)，没有实质性优化。
        
    
- ​**折半插入排序的复杂度 (总结)：​**​
    
    - ​**最坏情况： O(n2)​**​ (查找 O(logn)+ 移动 O(n)，共 n轮)
        
    - ​**最好情况： O(nlogn)​**​
        
        - ​**反向优化：​**​ 折半插入排序**反而使最好情况变差了**。
            
        - ​**对比 (最好情况)：​**​
            
            - ​**普通插入排序：​**​ `[1, 2, 3, 4, 5, 6]`| `[7]`。插入 7，只需和 6 比较 1 次 (O(1))。总时间 O(n)。
                
            - ​**折半插入排序：​**​ `[1, 2, 3, 4, 5, 6]`| `[7]`。插入 7，需要对 `[1...6]`进行**二分查找**来确定 7 应该在 6 之后。此查找耗时 O(logn)。总时间 O(nlogn)。
                
            
        
    
