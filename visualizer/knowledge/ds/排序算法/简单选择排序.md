## 6. 列表排序算法

### ※ 气泡排序 (Bubble Sort) - (课后练习)

* **核心逻辑**：(同向量) 遍历列表，若相邻节点 `P` 和 `P->succ` 存在逆序，则交换它们。
* **实现提示**：讲师建议学生课后**自行实现**基于列表的气泡排序算法，书中未给出代码。

### 6.1 选择排序 (Selection Sort)

* **基本思想**：(对气泡排序的改进)
    * 气泡排序每趟扫描需要 $O(n)$ 次比较和 $O(n)$ 次交换。
    * 选择排序的核心思路是：每趟扫描通过 $O(n)$ 次比较**找出**当前未排序区间中的最大元素 $M$，然后**仅需一次**“就位”操作。

#### 6.1.1 实现方法：交换法 vs 平移法

* **1. 交换法 (Exchange Method)** - (※ PPT 讲解，非代码实现)
    * **逻辑**：
        1.  在未排序区间 `[0, n-1]` 中通过 `selectMax` 找到最大元素所在的**节点 M**。
        2.  将节点 M 的**数据** `M->data` 与未排序区间的**最后节点 L** 的数据 
        `L->data` 进行**交换 (swap)**。
        3.  缩小未排序区间，重复此过程。

* **2. 平移法 (Translation Method)** - (※ **课程代码实现**)
    * **逻辑**：
        1.  在未排序区间 `[0, n-1]` 中通过 `selectMax` 找到最大元素所在的**节点 M**。
        2.  将节点 M 从列表中**删除 (`remove(M)`)**。
        3.  将节点 M **插入 (`insert`)** 到已排序区间的**最前端**（例如，作为 `trailer` 节点的前驱）。
    * **“平移”的本质**：
        * PPT 动画效果看似是 M 之后的元素 (如 1, 3, 5) **向前移动**了。
        * **物理实质**：1, 3, 5 等节点的**物理内存地址完全没有改变**。
        * 改变的只是**指针**。例如，`remove(M)` 操作会修改 M 的前驱（如节点 4）的 `succ` 指针，使其指向 M 的后继（如节点 5）。
    * **平移法优势**：
        * `selectMax` 查找最大值是 $O(n)$。
        * 但后续的“就位”操作（即 `remove` + `insert`）**均是 $O(1)$** 的指针操作。

#### 6.1.2 性能与稳定性分析

* **`selectMax` 的实现约定**：
    * 为了保证稳定性，`selectMax` 必须返回**命中多个最大者中的最后者（最靠右者）**。
    * (注：课程代码实现 `selectMax(P, n)` 时，采用从后向前遍历或特定比较逻辑，可保证选中最后者)。

* **平移法的稳定性**：
    * **结论**：**稳定 (Stable)**。
    * **原因**：
        1.  `selectMax` 总是选择**最右侧**的最大值（如 `6c`）。
        2.  平移法（`remove` + `insert`）是将其**整个节点**移走，**不会**影响其他相等元素（如 `6a`, `6b`）的相对次序。
        3.  其他非最大元素（如 1, 5）虽然逻辑上前移（指针修改），但它们之间的相对次序也未改变。

* **时间复杂度**：
    * 总共进行 $n$ 趟迭代。
    * 第 $k$ 趟迭代：`selectMax` 需要比较 $O(n-k)$ 次；“就位”操作（平移法）为 $O(1)$。
    * **总复杂度**：$T(n) = \sum_{k=1}^{n} (O(n-k) + O(1)) = O(n^2)$。
    * **重要**：选择排序的比较次数是固定的，与输入数据是否有序无关。因此，其**最好、最坏、平均时间复杂度均为 $\Theta(n^2)$**。

* **$\Theta(n^2)$ 的原因（“熊瞎子劈苞米”）**：
    * 即使是最好情况（已排序的 `1,2,3,4,5,6,7`），算法也必须执行 $n$ 趟。
    * **第1趟**：为找 7，比较了 `(1,2)`, `(2,3)`, `(3,4)`...
    * **第2趟**：为找 6，**再次**比较 `(1,2)`, `(2,3)`, `(3,4)`...
    * 算法**没有“记忆”**（保存）前一趟比较的结果，导致了大量的**冗余比较**。

#### 6.1.3 算法改进与勘误

* **选择排序的改进 (堆排序)**：
    * **思路**：解决“熊瞎子劈苞米”的冗余比较问题。
    * **方法**：使用**优先级队列 (Priority Queue)**（即**堆 Heap**）来维护未排序元素。
    * **PPT 勘误**：PPT 提及 `selectMax` 可改进至 $O(\log n)$，这是**有前提**的，该表述不严谨。
    * **正确流程 (堆排序)**：
        1.  **预处理 (建堆)**：花费 $O(n)$ 时间将所有元素建成一个最大堆。
        2.  **选择与调整**：后续**每次** `selectMax`（即 `getMax` 从堆顶取最大值 $O(1)$） + 调整堆（`downHeap` $O(\log n)$）。
    * **总复杂度**：$O(n) \text{ (建堆)} + n \times O(\log n) \text{ (n次删除)} = O(n \log n)$。

* **※ 术语说明**：
    * 本课程中（邓老师教材），“**选择排序**” 默认指的就是这个 $O(n^2)$ 的**简单选择排序**。
    * “**堆排序**” 被视为选择排序的一个**改进版本**，归属于选择排序大类。

---

> [!WARNING] 重点勘误：习题解析 3-9 (稳定性问题)
> * **问题背景**：习题 3-9 要求实现基于**向量 (Vector)** 的**交换法**选择排序。
> * **习题解析（错误结论）**：习题解析的答案中断言：“该算法（交换法 + `selectMax` 选中后者优先）是**稳定**的。”
> * **讲师纠正**：**这是错误的！**
>
> * **交换法 (Swap) 不稳定的反例**：
>     * **输入**：`[ 2a, 2b, 1a, 1b ]` (假设 2a, 2b 和 1a, 1b 分别是值相等的不同元素)
>     * **第1趟**：
>         1.  `selectMax` 找到 `[2a, 2b, 1a, 1b]` 中的最大值，按“后者优先”原则，选中 **2b**。
>         2.  将 **2b** 与当前区间的最后元素 **1b** 进行**交换 (swap)**。
>         3.  **结果**：`[ 2a, 1b, 1a, 2b ]`
>     * **结论**：**1a** 和 **1b** 的相对次序被**破坏**了（1b 跑到了 1a 的前面）。因此，**基于交换法 (Swap) 的选择排序是 不稳定的**。
>
> * **学习提醒**：必须对照**勘误表 (Errata)** 修正教材和习题解析，否则可能被错误内容误导。

---

### 总结：平移法 vs 交换法 (稳定性与默认实现)

1.  **平移法 (Translation)**：
    * **稳定性**：**稳定** (前提是 `selectMax` 选后者)。
    * **列表 (List) 实现**：`remove` + `insert` 操作为 $O(1)$。总复杂度 $\Theta(n^2)$。**这是列表的默认实现**。
    * **向量 (Vector) 实现**：`remove` + `insert` 涉及 $O(n)$ 的元素移动。总复杂度 $\Theta(n^3)$（或 $\Theta(n^2)$ 但常数因子极大），**效率低，不被采用**。

2.  **交换法 (Swap)**：
    * **稳定性**：**不稳定** (见 3-9 反例)。
    * **向量 (Vector) 实现**：`swap` 操作为 $O(1)$。总复杂度 $\Theta(n^2)$。**这是向量的默认实现**（因为它避免了平移法在向量上的高昂移动代价）。
    * **列表 (List) 实现**：虽然也可以做（例如只交换 `data` 域），但平移法 $O(1)$ 的“移动”开销更具优势且能保证稳定性，故列表默认使用平移法。