# 双连通分量 (Biconnected Components)

  

## 基本概念

  

### 关节点 (Articulation Point)

- **定义**: 在无向图中，如果删除某个顶点后，原图的连通分量数量增加，则该顶点称为关节点

- **性质**:

  - 叶节点不可能是关节点

  - 根节点只有当其子树数≥2时才是关节点

  - 内部节点v是关节点当且仅当存在某个孩子u，使得以u为根的子树无法通过后向边连接到v的任何真祖先

  

### 双连通图

- **定义**: 不含关节点的连通图称为双连通图

- **双连通分量**: 极大的双连通子图称为双连通分量(BCC)

  

## 算法思想

  

### 基于DFS的BCC算法

  

#### 核心思路

1. 构造DFS树，记录每个顶点的发现时间(disc_time)

2. 维护每个顶点能到达的最高祖先(highest_ancestor)

3. 通过后向边更新祖先信息

4. 根据祖先信息判断关节点并分离BCC

  

#### 关键数据结构

- `disc[v]`: 顶点v的发现时间

- `low[v]`: 顶点v能通过后向边到达的最高祖先的发现时间

- 栈: 存储当前BCC的顶点

  

#### 算法步骤

```cpp

#include <iostream>

#include <vector>

#include <stack>

#include <algorithm>

using namespace std;

  

class BCCSolver {

private:

    vector<vector<int>> graph;      // 图的邻接表表示

    vector<int> disc, low;          // disc: 发现时间, low: 能到达的最高祖先时间

    vector<int> parent;             // DFS树中的父节点

    vector<bool> visited;           // 访问标记

    stack<int> vertexStack;         // 存储当前BCC的顶点

    stack<pair<int, int>> edgeStack; // 存储当前BCC的边

    vector<vector<int>> bccs;       // 存储所有双连通分量

    int timeCounter;                // 全局时间计数器

public:

    BCCSolver(int n) : graph(n), disc(n, -1), low(n, -1),

                      parent(n, -1), visited(n, false), timeCounter(0) {}

    // 添加无向边

    void addEdge(int u, int v) {

        graph[u].push_back(v);

        graph[v].push_back(u);

    }

    // DFS递归函数：计算disc和low值，判断关节点和BCC

    void DFS(int v, int parent) {

        // 标记当前顶点为已访问，设置发现时间和low值

        visited[v] = true;

        disc[v] = low[v] = ++timeCounter;

        // 将当前顶点压入顶点栈

        vertexStack.push(v);

        int childCount = 0; // 记录子节点数量（用于根节点关节点判断）

        // 遍历当前顶点的所有邻居

        for (int u : graph[v]) {

            if (!visited[u]) {

                // 情况1：u是未访问的邻居 -> 树边

                childCount++;

                parent[u] = v; // 设置u的父节点

                // 递归访问u

                DFS(u, v);

                // 回溯时更新当前顶点的low值

                low[v] = min(low[v], low[u]);

                // 判断关节点条件

                // 非根节点：存在子树无法回到祖先

                // 根节点：子树数 >= 2

                if (parent != -1 && low[u] >= disc[v]) {

                    // v是关节点

                    cout << "关节点: " << v << endl;

                    // 弹出BCC中的顶点直到u

                    extractBCC(u);

                }

                // 根节点的特殊判断

                if (parent == -1 && childCount > 1) {

                    cout << "根关节点: " << v << endl;

                    extractBCC(-1); // 特殊处理根节点

                }

            } else if (u != parent && disc[u] < disc[v]) {

                // 情况2：u是已访问的邻居且不是父节点 -> 后向边

                // disc[u] < disc[v] 确保只处理一次

                low[v] = min(low[v], disc[u]);

                // 将后向边压入边栈

                edgeStack.push({v, u});

            }

        }

    }

    // 提取双连通分量

    void extractBCC(int stopVertex) {

        vector<int> bcc;

        // 弹出顶点直到遇到stopVertex

        while (!vertexStack.empty()) {

            int vertex = vertexStack.top();

            vertexStack.pop();

            bcc.push_back(vertex);

            if (vertex == stopVertex) break;

        }

        if (!bcc.empty()) {

            bccs.push_back(bcc);

            cout << "BCC: ";

            for (int v : bcc) cout << v << " ";

            cout << endl;

        }

    }

    // 主求解函数

    void solve() {

        for (int i = 0; i < graph.size(); i++) {

            if (!visited[i]) {

                DFS(i, -1);

                // 处理剩余的BCC

                if (!vertexStack.empty()) {

                    extractBCC(-1);

                }

            }

        }

    }

    // 获取所有双连通分量

    vector<vector<int>> getBCCs() {

        return bccs;

    }

};

  

// 使用示例

int main() {

    // 创建图：6个顶点，7条边

    BCCSolver solver(6);

    solver.addEdge(0, 1);

    solver.addEdge(1, 2);

    solver.addEdge(2, 0);

    solver.addEdge(1, 3);

    solver.addEdge(3, 4);

    solver.addEdge(4, 5);

    solver.addEdge(5, 3);

    cout << "双连通分量分析结果:" << endl;

    solver.solve();

    return 0;

}

```

  

## 复杂度分析

  

- **时间复杂度**: O(V + E)，与普通DFS相同

- **空间复杂度**: O(V + E)，需要额外的栈空间

  

## 重要性质

  

1. **关节点判定**:

   - 根节点: 子树数≥2时才是关节点

   - 非根节点: 存在子树无法回到祖先时才是关节点

  

2. **BCC特性**:

   - BCC之间通过关节点连接

   - 同一个BCC内的顶点low值不一定相同

  

## 算法实现要点

  

1. **初始化**: disc[v] = low[v] = v的发现时间

2. **后向边处理**: 更新low值

3. **回溯处理**: 根据low值判断关节点并分离BCC

4. **栈操作**: 维护当前BCC的顶点集合

  

> [!NOTE]

> 该算法适用于无向图。对于有向图的强连通分量，需要不同的处理方式。

  

## 应用场景

- 网络拓扑分析

- 关键节点识别

- 网络可靠性评估

- 电路板设计中的关键连接点识别