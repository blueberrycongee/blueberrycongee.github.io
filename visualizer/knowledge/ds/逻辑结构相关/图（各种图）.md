[[无向图]]

[[有向图]]

[[简单图]]

[[混合图]]

[[非简单图]]

[[环路]]

[[哈密尔顿环路]]

[[DAG]]

[[平面图e≤3n-6]]

[[稠密图&稀疏图]]


---

# 图 (Graph) - 讲座笔记

## 章节概述与备考策略

本章内容整合了“图”与“图的应用”两部分。

### 考情特点

- **考试比重：** 必考，但分值占比可能没有想象中那么高。平均分可能达不到 $70 / 12 \approx 5.8$ 分。
    
- **难度：** 存在一定难度，算法较为繁琐，代码实现较长。
    

> [!WARNING] 考点差异：与 408 及其他教材的对比
> 
> - 邓老师的教材中，图的篇幅和知识点比例相对均衡，不像某些教材中图的占比特别大。
>     
> - **关键路径 (Critical Path) 问题：** 在邓老师的教材、习题、历年真题中均**未出现过**，基本可以认为不在 826 考试范围内。
>     

### 复习策略

> [!TIP] 备考时间紧张策略 (例如 10 月、11 月)
> 
> 如果时间紧迫，应放弃抠代码细节，重点掌握算法逻辑：
> 
> 1. **图的存储结构**：邻接矩阵和邻接表。
>     
> 2. **BFS / DFS**：遍历过程和逻辑。
>     
> 3. **最小生成树 (MST)**：Prim 和 Kruskal 算法逻辑。
>     
> 4. **最短路径**：Dijkstra 和 Floyd 算法逻辑。
>     
> 
> 对于时间充裕（如 5 月）的同学，仍需仔细研读，彻底吃透知识点。

---

## 1. 图的基本术语

本节课内容（基本概念和存储结构）相对简单。

### 1.1 顶点与边

- **图 (Graph) $G$：** 由 **顶点集 $V$ (Vertex)** 和 **边集 $E$ (Edge)** 构成，记为 $G = (V, E)$。
    
- **关联 (Incidence)：** 顶点与边的关联关系。
    
- **邻接 (Adjacency)：** 同一条边的两个顶点彼此邻接。
    
- **自环 (Self-loop)：** 连接同一个顶点的边。 自己连自己
    
- **重边 (Multiple Edges)：** 连接相同两个顶点的多条边。
    

> [!IMPORTANT] 简单图 (Simple Graph)
> 
> - **定义：** 不包含自环和重边的图。
>     
> - **默认假设：** 课程中如未明确说明，**一律按简单图处理**。非简单图暂时不讨论。
>     

- **度 (Degree)：** 与同一顶点关联的边数。
    一个点连了几个边

### 1.2 图的类型

1. **无向图 (Undirected Graph)：** 所有边均无方向。
    
2. **有向图 (Directed Graph / Digraph)：** 所有边均有方向。
    
    - **出度 (Out-degree)：** 以该顶点为起点的边数。
        
    - **入度 (In-degree)：** 以该顶点为终点的边数。
        
    - **通用性：** 有向图的通用性更强，本章主要针对有向图介绍算法。
        
3. **混合图 (Mixed Graph)：** 同时包含有向边和无向边。
    
    - **注意：** 考试中基本不考虑，除非题目明确画出或说明。不要用混合图的特例去“抬杠”常规的有向/无向图结论。
        

### 1.3 路径、环路与图

- **路径 (Path)：** 顶点序列 $v_0, v_1, ..., v_k$，其中 $(v_{i-1}, v_i) \in E$。
    
- **路径长度 (Length)：** 路径中边的数量，即 $k$。
    
- **环路 (Cycle)：** 起点和终点重合的路径（$v_0 = v_k$）。例如 $A \to B \to C \to A$。
    
- **有向无环图 (DAG)：**
    
> [!NOTE] DAG 缩写
> 
> Directed Acyclic Graph。'A' (Acyclic) 作为否定前缀，意为“无环的”。
    
- **欧拉环路 (Eulerian Cycle)：**
    
    - 通过图中**每条边**恰好一次的环路。
        
    - **注意：** 欧拉环路大概率不是唯一的。
        
- **哈密顿环路 (Hamiltonian Cycle)：**
    
    - 通过图中**每个顶点**恰好一次的环路。
        
    - **注意：** 哈密顿环路大概率也不是唯一的。
        

### 1.4 支撑树 (Spanning Tree)

- **支撑树 (Spanning Tree)：**
    
    - 图 $G$ 的一个子图 $T$。
        
    - $T$ 必须是一棵树（无环）。
        
    - $T$ 必须包含 $G$ 的**所有顶点**。
        
    - **注意：** 同一个图的支撑树通常不唯一。
        
- **最小支撑树 (MST - Minimum Spanning Tree)：**
    
    - **网络 (Network)：** 带权图。
        
    - **定义：** 在一个网络中，所有支撑树里，边的权重之和最小的那个。
        
    - **注意：** 最小支撑树也**不一定唯一**（可能存在多棵权重总和相同的树）。
        

---

## 2. 图的存储结构

图是一种逻辑结构，需要物理存储实现。

### 2.1 邻接矩阵 (Adjacency Matrix)

- **定义：** 记录**顶点与顶点**之间邻接关系的 $n \times n$ 矩阵（$n = |V|$）。
    
- **无权图：** $A[i][j] = 1$ (若 $(v_i, v_j) \in E$)； $A[i][j] = 0$ (若 $(v_i, v_j) \notin E$)。
    
- **带权图：** $A[i][j] = w_{ij}$ (若 $(v_i, v_j) \in E$)； $A[i][j] = 0$ 或 $\infty$ (若 $(v_i, v_j) \notin E$)。
    
- **简单图：** 对角线 $A[i][i] = 0$。
    
- **无向图：** 邻接矩阵是**对称矩阵**（$A[i][j] = A[j][i]$）。
    

> [!NOTE] 无向图对称矩阵的压缩存储
> 
> - 由于无向图的邻接矩阵是对称的，可以只存储上三角或下三角部分，实现空间压缩（例如存入一个一维数组）。
>     
> - 这在习题解析中有涉及，并且**真题考过**。
>     
> - 虽然压缩了，但  空间  复杂度级别仍是 $O(n^2)$。
>     
[[邻接表&邻接矩阵]]
#### 复杂度与特性

- **空间   复杂度：** $\Theta(n^2)$。
    
- **优点：**
    
    1. 直观，易于理解和实现。
        
    2. 适用于**稠密图 (Dense Graph)**（$e \approx O(n^2)$），空间利用率高。
        
    3. 判断边 $(u, v)$ 是否存在：$\Theta(1)$。
        
    4. 获取顶点 $v$ 的出度/入度：$\Theta(1)$（见下方邓氏实现）。
        
    5. 添加/删除边后更新度数：$\Theta(1)$。
        
- **缺点：**
    
    1. 空间复杂度与边数 $e$ 无关。
        
    2. 对于**稀疏图 (Sparse Graph)**（$e \approx O(n)$），空间浪费严重。
        

> [!INFO] 邓氏实现与 408 的差异 (关于 $O(1)$ 获取度)
> 
> - **邓氏实现：** 图的类 (Class) 中，除了存储邻接矩阵，还**额外存储了每个顶点的出度 (out-degree) 和入度 (in-degree) 作为成员变量**。
>     
> - **操作：** 在 `insertEdge()` 或 `removeEdge()` 时，除了修改矩阵，还会**同步更新**受影响顶点的度变量。
>     
> - **结论：** 因此，获取度数（`degree(v)`）只是一个 $\Theta(1)$ 的变量读取操作。
>     
> - **408 实现：** 可能不默认存储度数，获取 $v$ 的出度需要遍历矩阵的第 $v$ 行，复杂度为 $\Theta(n)$。
>     
> - **考试中：** 以邓老师书中的实现为准，认为是 $\Theta(1)$。
>     

#### C++ 示例 (邻接矩阵)

```cpp
// 邻接矩阵的实现思路 (邓氏风格)
// 顶点 Vertex
template <typename Tv>
struct Vertex {
    Tv data; 
    int inDegree, outDegree; // 显式存储入度和出度
    VStatus status;
    // ... 构造函数 ...
    Vertex(Tv const& d = (Tv) 0) : 
        data(d), inDegree(0), outDegree(0), status(UNDISCOVERED) {}
};

// 边 Edge
template <typename Te>
struct Edge {
    Te data; 
    int weight; 
    EStatus status;
    // ... 构造函数 ...
    Edge(Te const& d, int w) : data(d), weight(w), status(UNDETERMINED) {}
};

// 图 GraphMatrix
template <typename Tv, typename Te>
class GraphMatrix {
private:
    Vector<Vertex<Tv>> V; // 顶点集
    Vector<Vector<Edge<Te>*>> E; // 边集 (邻接矩阵)

public:
    int n; // 顶点数
    int e; // 边数

    // 插入边 (重点)
    virtual void insert(Te const& edgeData, int w, int i, int j) {
        if (exists(i, j)) return; // 边已存在
        E[i][j] = new Edge<Te>(edgeData, w); // 创建新边
        e++; // 更新边数
        
        // 关键：同步更新顶点的度
        V[i].outDegree++; 
        V[j].inDegree++;
    }

    // 获取出度 (O(1))
    virtual int outDegree(int i) { return V[i].outDegree; }
    
    // ... 其他接口 (remove, exists, etc.) ...
};
```

### 2.2 关联矩阵 (Incidence Matrix)

- **定义：** 记录**顶点与边**之间关联关系的 $n \times e$ 矩阵（$n = |V|, e = |E|$）。
    
- $B[i][j] = 1$ (若顶点 $v_i$ 是边 $e_j$ 的一个端点)。
    

> [!DANGER] 空间效率极低
> 
> - **空间复杂度：** $\Theta(n \times e)$。
>     
> - 在最坏情况下（稠密图），$e$ 可能是 $O(n^2)$ 级别，导致总空间复杂度达到 $\Theta(n^3)$。
>     
> - 空间利用率低，其他教材中很少见。
>     

### 2.3 邻接表 (Adjacency List)

- **定义：** 结合了数组（顶点表）和链表（边表）。
    
- 创建一个大小为 $n$ 的向量（或数组），每个元素 $V[i]$ 对应一个顶点。
    
- $V[i]$ 指向一个链表，链表中存储了所有从 $v_i$ 出发的边的**终点**（或边的信息）。
    
0 — 1
|   \
2     3
V[0] → 1 → 2 → 3 → NULL
V[1] → 0 → NULL
V[2] → 0 → NULL
V[3] → 0 → NULL
#### 复杂度与特性

- **空间复杂度：** $\Theta(n + e)$。
    
- **优点：**
    
    1. 空间效率高，是**稀疏图**的标准存储方式。
        
    2. 遍历顶点 $v$ 的所有出边（邻居）非常高效，复杂度为 $\Theta(1 + \text{degree}(v))$。
        
- **缺点：**
    
    1. **判断边 $(u, v)$ 是否存在：** 效率较低。需要遍历 $u$ 的邻接链表，最坏时间复杂度为 $\Theta(\text{degree}(u))$。（讲师提到可用散列表等结构优化）。
        
- **无向图存储：**
    
    - 一条边 $(u, v)$ 会被存储两次：一次在 $u$ 的链表中（指向 $v$），一次在 $v$ 的链表中（指向 $u$）。
        

> [!INFO] 补充：邻接多重表 (Adjacency Multilist)
> 
> - **目的：** 解决无向图在邻接表中一条边存储两次的问题。
>     
> - **方法：** 边只存储一次，但包含多个指针域，将其串在两个相关顶点的链表中。
>     
> - **缺点：** 指针更多，结构更复杂。
>     
> - **考情：** 邓老师书中未涉及，考试不考，了解即可。
>     

#### C++ 示例 (邻接表)


```cpp
#include <vector>
#include <list>
#include <map>

// 邻接表的实现思路 (C++ STL)
// 假设 E_info 存储边的信息 (如权重)
template <typename E_info>
class GraphAdjacencyList {
public:
    int n; // 顶点数
    int e; // 边数

    // 使用 vector 存储顶点表，每个顶点的邻接表使用 list
    // (pair<int, E_info> 中 int 是邻接顶点的索引)
    std::vector<std::list<std::pair<int, E_info>>> adj;

    GraphAdjacencyList(int numVertices) : n(numVertices), e(0) {
        adj.resize(n);
    }

    // 插入边 (u -> v)
    void insertEdge(int u, int v, E_info info) {
        // 这里未检查边是否重复，实际实现需要检查
        adj[u].push_back({v, info});
        e++;
        
        // 注意：邓氏实现中，顶点结构体里也会存度数并同步更新
        // V[u].outDegree++; V[v].inDegree++;
    }

    // 检查边 (u -> v) 是否存在 (O(degree(u)))
    bool exists(int u, int v) {
        for (const auto& edge : adj[u]) {
            if (edge.first == v) {
                return true;
            }
        }
        return false;
    }
    
    /*
    // 优化：如果判断边存在性的操作频繁
    // 可以用 map (红黑树) 或 unordered_map (散列表)
    // std::vector<std::map<int, E_info>> adj_optimized;
    // 检查边 (u -> v) (O(log degree(u)) 或 O(1))
    bool exists_optimized(int u, int v) {
        return adj_optimized[u].count(v) > 0;
    }
    */
};
```

---

## 3. 稀疏图 vs 稠密图

- **稠密图 (Dense Graph)：** 边数 $e$ 接近 $n^2$ 的上界，即 $e = O(n^2)$。
    
    - 例如 $e = \frac{1}{8}n^2$ 或 $\frac{1}{16}n^2$，在 $n$ 很大时都算稠密。
        
- **稀疏图 (Sparse Graph)：** 边数 $e$ 远小于 $n^2$，即 $e = O(n)$。
    

> [!NOTE] 边界模糊性
> 
> - 讲师强调，“稀疏”和“稠密”之间**没有一个严格的数学定义边界**。
>     
> - 例如 $e = n \log n$，它介于 $O(n)$ 和 $O(n^2)$ 之间，很难界定。
>     
> - 但在算法分析时，通常 $O(n)$ 级别视为稀疏， $O(n^2)$ 级别视为稠密。
>     

---

## 4. 平面图 (Planar Graph)

- **定义：** 可以被绘制（嵌入）在一个平面上，且所有边均不交叉的图。
    

> [!IMPORTANT] 平面图定理 (Euler's Formula related)
> 
> - 对于一个顶点数 $n \ge 3$ 的简单平面图，其边数 $e$ 必须满足：
>     
>     $$e \le 3n - 6$$
>     
> - **推论：** 平面图的边数 $e$ 是 $O(n)$ 级别的，因此**平面图一定是稀疏图**。
>     
> - **应用：**
>     
>     - 使用邻接矩阵存储平面图，空间利用率仅为 $O(n) / O(n^2) = O(1/n)$，效率极低。
>         
>     - 平面图必须使用邻接表。
>         
> - **示例 (K5)：**
>     
>     - $K_5$ 是 5 个顶点的完全图。
>         
>     - 顶点数 $n = 5$。
>         
>     - 边数 $e = C(5, 2) = 10$。
>         
>     - 根据平面图定理， $n=5$ 时， $e$ 最多为 $3n - 6 = 3(5) - 6 = 9$。
>         
>     - 由于 $10 > 9$，所以 **$K_5$ 不是平面图**。无论你怎么画，它在平面上都必然有边交叉。
>         

---

## 5. 存储结构总结与取舍

| **特性**           | **邻接矩阵 (Adjacency Matrix)**      | **邻接表 (Adjacency List)**                                        |
| ---------------- | -------------------------------- | --------------------------------------------------------------- |
| **空间复杂度**        | $\Theta(n^2)$                    | $\Theta(n + e)$                                                 |
| **适用图**          | **稠密图**                          | **稀疏图** (尤其是平面图)                                                |
| **判断边 $(u, v)$** | $\Theta(1)$                      | $O(\text{degree}(u))$ (可优化为哈希) 如果使用散列表实现，平均降为$O（1）$             |
| **遍历 $u$ 的邻居**   | $\Theta(n)$                      | $\Theta(\text{degree}(u))$                                      |
| **获取 $u$ 的度**    | $\Theta(1)$ (邓氏实现) / $\Theta(n)$ | $\Theta(1)$ (若存) / $\Theta(\text{degree}(u))$ (若遍历)             |
| **插入/删除边**       | $\Theta(1)$                      | $\Theta(1)$ (插) / $O(\text{degree}(u))$ (删) 如果使用哈希 删也会变成 $O(1)$ |


**取舍原则：** 如果算法需要频繁进行**遍历**（如 BFS, DFS, Dijkstra 等），邻接表是更好的选择。如果需要频繁**判断任意两点间是否存在边**，邻接矩阵更优。