# 计算机笔记整理：【二叉树 Part 2】

> 笔记内容：真二叉树，二叉树的先、中、后序遍历（递归与非递归），表达式树。

## 1. 真二叉树 (Proper/Full Binary Tree)

### 1.1 概念定义

- ​**真二叉树**​：一个二叉树，其中所有的结点的度（degree）​**要么为 0（叶节点），要么为 2（分支节点）​**。
    
- 它没有度为 1 的结点。
    
- ​**澄清**​：真二叉树是一个本身的定义，不要误以为它必须通过“引入外部结点”的方式由原二叉树拓展而来。一个二叉树可能其本身就是一个真二叉树。
    

### 1.2 拓展为真二叉树

- 任意一个二叉树，如果它本身不是真二叉树，可以通过引入“外部结点”的方式，将其**拓展 (extend)​**​ 成一个真二叉树。
    
- 这种转换（例如为 `n1`个度为1的结点和 `n0`个叶节点添加外部结点）并不会实质性增加树的复杂度。
    
- 如果原树有 n 个结点，空间复杂度为 O(n)，拓展后的结点数虽然增加了，但仍是 O(n)级别，只是增加了一个常数系数。
    

### 1.3 应用

- 对于某些高级数据结构（如：​**红黑树**），使用真二叉树的概念可以**简化其描述、理解、实现和分析**。
    

---

## 2. 二叉树的遍历 (Tree Traversal)

### 2.1 遍历的重要性

- 遍历是二叉树的一个**重要考点**。
    
- 虽然可能不直接考遍历代码，但它会涉及到后续内容，例如**二叉树的重构**​（下次课内容，考过）。
    
- ​**非递归遍历**​ 曾经在真题中考过（例如 2017 年考过非递归的中序遍历）。
    

### 2.2 先序遍历 (Pre-order Traversal)

#### 2.2.1 递归实现 (Recursive)

- ​**顺序**​：​**根 (Root) -> 左 (Left) -> 右 (Right)​**。
    
- ​**实现**​：代码非常简单，核心只有三行。
    
    1. （检查基线情况，如 `if (!x) return;`）
        
    2. `visit(x->data)`(访问根)
        
    3. `traverse(x->leftChild)`(递归遍历左子树)
        
    4. `traverse(x->rightChild)`(递归遍历右子树)
        
    
- ​**示例**​：(G(F(A, E(C(B), D)))) 的先序遍历为 G, F, A, E, C, B, D。
    
- ​**局限**​：依赖于系统调用栈，如果递归深度过深，可能超出栈的限制。
    

#### 2.2.2 递归应用：统计树的规模

- 先序遍历的递归框架可用于多种计算，例如**统计树的规模（结点总数）​**。
    
- ​**思路**​：
    
    1. 初始化规模 `s = 1`（计入当前根结点）。
        
    2. 如果存在左子树，`s += traverse(x->leftChild)`（递归计入左子树规模）。
        
    3. 如果存在右子树，`s += traverse(x->rightChild)`（递归计入右子树规模）。
        
    4. `return s`。
        
    

#### 2.2.3 非递归实现 (Iterative) - 辅助栈法

- ​**核心思想：藤 (Vine) 分解**​
    
    - 将遍历过程看作：1. ​**自上而下**沿着“**左藤**”（leftmost vine，即从根开始一路向左的路径）访问结点。 2. ​**自下而上**遍历访问过的各个“藤”结点的**右子树**。
        
    
- ​**辅助数据结构：栈 (Stack)​**​
    
    - 在沿“藤”下降的过程中，我们会**依次**发现 T0​,T1​,...,TD​（各个结点的右子树）。
        
    - 但是根据先序遍历的逻辑，访问完左“藤”后，我们访问 TD​的顺序是**逆序**的（先 TD​，再 TD−1​...）。
        
    - ​**后发现的先访问**，这符合**LIFO (后进先出)​**​ 的特性，因此选用**栈**。
        
    
- ​**算法实现**​
    
    1. ​**辅助函数 `visitAlongVine(x, S)`**​
        
        - 目的：从结点 `x`出发，沿左藤一路向下访问，并将**右孩子**入栈。
            
        - 循环 (`while (x)`)：
            
            - `visit(x->data)`(访问当前结点)
                
            - `S.push(x->rightChild)`(将其**右孩子**入栈，​**无论是否为 null**)
                
            - `x = x->leftChild`(移动到左孩子)
                
            
        
    2. ​**主循环 `traverse(root)`**​
        
        - 初始化栈 `S`。
            
        - `x = root`。
            
        - `while (true)`：
            
            - `visitAlongVine(x, S)`(访问当前结点为根的左藤)
                
            - `if (S.isEmpty()) break;`(栈空，遍历完成)
                
            - `x = S.pop();`(弹出之前保存的右子树根，准备下一轮)
                
            
        
    
- ​**算法示例**​：(详细过程：A入栈C，B入栈null，弹出C，C入栈F，D入栈E，弹出E，E入栈null，弹出F，F入栈null，G入栈null...)
    
- ​**`visitAlongVine`的优化讨论**​
    
    - ​**问题**​：将 `null`右孩子入栈（如 `S.push(x->rightChild)`）是否值得？能否增加判断 `if (x->rightChild)`再 `push`？
        
    - ​**分析**​：
        
        1. ​**不加判断（原版）​**​：逻辑简单，但会`push`和`pop`很多`null`值。
            
        2. ​**增加判断 `if (x->rightChild)`**​：
            
            - ​**空间**​：​**一定更优**。避免了`null`指针入栈，节省了栈空间。
                
            - ​**时间**​：
                
                - 增加了 `if`判断本身的时间消耗。
                    
                - 但减少了 `push`和 `pop`操作的时间。
                    
                - ​**极端情况1（几乎都有右孩子）​**​：徒增了判断时间，性能略微劣化。
                    
                - ​**极端情况2（几乎都没有右孩子）​**​：​**显著减少**了大量 `null`的 `push`和 `pop`时间，性能提升。
                    
                
            
        
    - ​**结论**​：​**值得优化**。在大多数情况下，尤其是在树比较稀疏时，​**增加判断**​（避免`null`入栈）在时间和空间上**大概率都有优势**。
        
    

---

### 2.3 中序遍历 (In-order Traversal)

#### 2.3.1 递归实现 (Recursive)

- ​**顺序**​：​**左 (Left) -> 根 (Root) -> 右 (Right)​**。
    
- ​**实现**​：与先序递归类似，只是 `visit`语句放到了中间。
    
- ​**复杂度**​：O(n)。
    

#### 2.3.2 可视化技巧

- 如果二叉树绘制得“标准”（即所有左孩子在根的左侧，右孩子在根的右侧），将其所有结点**向水平轴（X轴）做投影**。
    
- 从左到右读取投影点的顺序，即为**中序遍历序列**。
    
- _注意_：如果树画得不标准（如左孩子画在右边），此方法会出错。
    

#### 2.3.3 非递归实现 (Iterative) - 辅助栈法

- ​**核心思想：藤 (Vine) 分解**​
    
    - 与先序不同，中序遍历必须先**深入到最左侧**，访问最左结点，然后才访问其根，最后处理其右子树。
        
    
- ​**算法实现**​
    
    1. ​**辅助函数 `goAlongVine(x, S)`**​
        
        - 目的：从结点 `x`出发，沿左藤一路向下，将**沿途所有结点**入栈。
            
        - ​**注意**​：此过程**不访问 (visit)​**​ 结点。
            
        - 循环 (`while (x)`)：
            
            - `S.push(x)`(当前结点入栈)
                
            - `x = x->leftChild`(移动到左孩子)
                
            
        
    2. ​**主循环 `traverse(root)`**​
        
        - 初始化栈 `S`。
            
        - `x = root`。
            
        - `while (true)`：
            
            - `goAlongVine(x, S)`(将当前根及其左藤入栈)
                
            - `if (S.isEmpty()) break;`(栈空，遍历完成)
                
            - `x = S.pop();`(弹出结点)
                
            - `visit(x->data)`(**出栈时访问**该结点)
                
            - `x = x->rightChild`(转向其**右子树**，准备下一轮循环)
                
            
        
    
- ​**示例**​：(B入栈, A入栈 -> A出栈访问 -> B出栈访问 -> F入栈, D入栈, C入栈 -> C出栈访问 -> D出栈访问 -> E入栈 -> E出栈访问 -> F出栈访问 -> G入栈 -> G出栈访问)
    
- ​**复杂度分析：O(n)​**​
    
    - ​**疑问**​：`goAlongVine`单次调用最差 O(n)（例如退化成链），它又在主循环中，是否总复杂度为 O(n2)？
        
    - ​**解答（均摊分析）​**​：​**不是 O(n2)​**，而是 O(n)。
        
    - ​**理由**​：
        
        1. 算法总时间 约等于 栈的 `push`和 `pop`操作总次数。
            
        2. `pop`操作：仅在主循环中执行，每个结点有 `n`个，​**每个结点最多被 `pop`一次**​（因为出栈后就访问了）。`pop`总次数 ≤O(n)。
            
        3. `push`操作：仅在 `goAlongVine`中执行。
            
        4. ​**关键**​：在整个算法生命周期中，​**`push`的总次数 必须等于 `pop`的总次数**​（栈从空到空）。
            
        5. 因此，`push`的总次数也是 O(n)。
            
        6. ​**结论**​：总时间复杂度为 O(n)。
            
        
    

#### 2.3.4 非递归实现 (Iterative) - 寻找后继法

> [!TIP] 考情提示
> 
> 这是 ​**2017 年**左右的考研真题，要求实现 `first`和 `next`(后继) 函数，并分析时间复杂度。

- ​**核心思想**​：
    
    1. 找到中序遍历的第一个结点 `t = first(root)`。
        
    2. 循环 `while (t)`：
        
        - `visit(t)`
            
        - `t = next(t)`(不断寻找下一个后继)
            
        
    
- ​**算法实现**​
    
    1. ​**`first(x)`函数**​：
        
        - 找到以 `x`为根的子树中，中序遍历的第一个结点（即最左侧结点）。
            
        - 实现：`while (x->leftChild) x = x->leftChild; return x;`
            
        
    2. ​**`next(t)`(寻找后继) 函数**​：
        
        - ​**Case 1：`t`存在右子树**​
            
            - 后继是其**右子树中的最左侧结点**​ ("最靠左的右后代")。
                
            - 实现：`s = t->rightChild; while (s->leftChild) s = s->leftChild; return s;`
                
            
        - ​**Case 2：`t`不存在右子树**​
            
            - 后继是其**​“最低的左祖先”​**。
                
            - 含义：从 `t`向上回溯，直到遇到一个结点 `s`，使得 `s`是其父亲 `s->parent`的**左孩子**。这个**父亲**​ `s->parent`就是 `t`的后继。
                
            - 实现：`s = t; while (s->parent && s == s->parent->rightChild) s = s->parent; return s->parent;`(不断朝左上方移动，直到不是右孩子为止)。
                
            
        
    
- ​**复杂度分析：O(n)​**​
    
    - 虽然单次调用 `next`的时间可能很高（O(n)），但整个遍历过程的**均摊复杂度**是 O(n)。
        
    - ​**理由（均摊分析）​**​：每条树边（连接父子）在整个遍历过程中，最多被“向下”遍历一次（在寻找`first`或`Case 1`时），最多被“向上”遍历一次（在`Case 2`时）。总的遍历次数与边数（n-1）成正比，故为 O(n)。
        
    

---

### 2.4 后序遍历 (Post-order Traversal)

#### 2.4.1 递归实现 (Recursive)

- ​**顺序**​：​**左 (Left) -> 右 (Right) -> 根 (Root)​**。
    
- ​**复杂度**​：O(n)。
    

#### 2.4.2 递归应用：子树删除

- 后序遍历的“先处理孩子，再处理根”的特性，天然适用于**子树删除**​（释放内存）操作。
    
- 必须先递归地删除（`delete`）左子树和右子树，最后才能删除（`delete`）根结点，否则会造成内存泄漏。
    

#### 2.4.3 非递归实现 (Iterative) - 辅助栈法

> [!WARNING] 复杂度警告
> 
> 后序遍历的非递归实现是三者中最复杂的。

- ​**核心思想**​：
    
    1. 后序遍历的**第一个**被访问的结点，一定是**所有叶节点中，按中序遍历次序最靠左的那一个**。
        
    2. _澄清_：这句话不矛盾。例如 `C(A(B), D)`，叶节点是 {B, D}，B 的中序次序在 D 之前，所以 B 是第一个被访问的。
        
    
- ​**算法实现**​
    
    1. ​**辅助函数 `goToLeftmostLeaf(S)`**​（邓书中称 `gotoHLVFL`）
        
        - 目的：从栈顶结点出发，沿途将结点入栈，​**直至栈顶为后序遍历的下一个目标**​（即上述的“最左叶子”）。
            
        - 循环 (`while (x = S.top())`)：
            
            - `if (x->leftChild)`(尽可能向左)
                
                - `if (x->rightChild) S.push(x->rightChild);`(如果有右孩子，​**先 push 右孩子**)
                    
                - `S.push(x->leftChild);`(**再 push 左孩子**)
                    
                
            - `else`(没有左孩子，只能向右)
                
                - `S.push(x->rightChild);`
                    
                
            - _（注：若左右皆无，会push一个null，立即在下一轮循环中被pop）_
                
            
        
    2. ​**主循环 `traverse(root)`**​
        
        - 初始化栈 `S`，`S.push(root)`。
            
        - `x = root`（`x`始终指向**刚被访问过的结点**）。
            
        - `while (!S.isEmpty())`：
            
            - `if (S.top() != x->parent)`(判断栈顶是否为刚访问结点的父亲)
                
                - 如果**不是**​（意味着刚回溯到父节点，或刚开始），则需要**向深处探索**。
                    
                - 调用 `goToLeftmostLeaf(S)`。
                    
                
            - `x = S.pop();`(弹出栈顶结点，该结点是下一个要访问的)
                
            - `visit(x->data)`(访问该结点)
                
            
        
    
- ​**示例**​：(K入栈 -> goto(G, I) -> goto(H, B) -> goto(A) -> A出栈访问 -> B出栈访问 -> goto(g的右孩子F, E) -> goto(d, c) -> C出栈访问 -> D出栈访问 -> E出栈访问 -> F出栈访问 -> G出栈访问 -> H出栈访问 -> I出栈访问 -> G'出栈访问 -> K出栈访问)。
    

---

## 3. 表达式树 (Expression Tree)

### 3.1 概念

- 用于表示数学计算表达式的二叉树。
    
- 叶节点是**操作数**​（数字）。
    
- 分支节点是**运算符**​（+,-,*,/,!,^ 等）。
    

### 3.2 中缀表达式构造

- （讲义中未详述，提示可自行查阅资料）。
    
- 一个可行思路是：先将**中缀表达式转为后缀表达式**​（逆波兰表达式 RPN），再由后缀构造。
    

### 3.3 后缀表达式 (RPN) 构造表达式树

> [!TIP] 考情提示
> 
> 这是 ​**2016 年**的考研真题。

- ​**核心思想**​：利用**栈**模拟逆波兰表达式的计算过程，但将“计算”替换为“建树”。
    
- ​**辅助数据结构**​：一个**栈**，但栈中存放的是**表达式树的（根）指针**。
    
- ​**算法实现**​
    
    1. 从左到右扫描后缀表达式（RPN）。
        
    2. ​**遇到操作数**​（如 0, 1, 2...）：
        
        - 创建一个**新的单结点树**​（该操作数为根）。
            
        - 将该树的根指针**入栈**。
            
        
    3. ​**遇到运算符**​（如 !, +, *, ^...）：
        
        - ​**Case 1: 遇到一元运算符**​ (如 `!`)
            
            - 从栈中 `pop`​**一个**树 `T1`。
                
            - 创建一个新结点（以该运算符 `!`为根）。
                
            - 将 `T1`作为新结点的**左孩子**。
                
            - 将新结点（`!`）​**入栈**。
                
            
        - ​**Case 2: 遇到二元运算符**​ (如 `+`, `*`)
            
            - 从栈中 `pop`​**两个**树，​**注意顺序**​：先弹出的是 `T2`（右子树），后弹出的是 `T1`（左子树）。
                
            - 创建一个新结点（以该运算符 `+`为根）。
                
            - 将 `T1`作为新结点的**左孩子**，`T2`作为新结点的**右孩子**。
                
            - 将新结点（`+`）​**入栈**。
                
            
        
    4. 扫描完成后，栈中**仅剩一个**元素，即为整个表达式树的根。
        
    
- ​**示例**​：`0 ! 1 + 2 3 ! * 4 + 5 - ...`
    
    1. `0`-> `push(0)`
        
    2. `!`-> `T1=pop(0)`-> `push(! (T1) )`
        
    3. `1`-> `push(1)`
        
    4. `+`-> `T2=pop(1)`, `T1=pop(!)`-> `push( + (T1, T2) )`
        
    5. `2`-> `push(2)`
        
    6. `3`-> `push(3)`
        
    7. `!`-> `T1=pop(3)`-> `push(! (T1) )`
        
    8. `*`-> `T2=pop(!)`, `T1=pop(2)`-> `push( * (T1, T2) )`
        
    9. ...以此类推
        
    

---

## 4. 考情分析与学习建议

### 4.1 算法题难度感知

- 老师评估的难度（如非递归中序遍历、RPN建树）与学生感知的难度（学生反馈 6-8 分，满分 10）存在较大差距。
    
- ​**结论**​：学生的基础算法能力偏弱，需要及早开始针对性训练。
    

### 4.2 826 考研真题特点

- ​**算法题语法**​：对C/C++/伪代码的**语法要求不严格**。即使有小的语法错误（如忘声明），只要逻辑正确，基本不会扣分。
    
- ​**评分标准**​：​**不压分**。分数低纯粹是因为学生确实不会做，而不是老师刻意压低分数。
    
- ​**伪代码**​：考试有时要求写伪代码，这实际上是**放宽了要求**，降低了难度。
    
- ​**核心考点**​：​**树**​（二叉树、搜索树）是算法题的**绝对重点**。
    
    - 近 80% 的算法题都与二叉树或搜索树相关。
        
    - 近几年（2021, 2022, 2023, 2024, 2025）​**连续**考察了二叉树相关算法。
        
    
- ​**2025年考情**​：
    
    - 难度偏高，平均分下降（比 2024 平均分低 5 分左右）。
        
    - 网研院平均分 88，最高分 99（未过百）。
        
    - 算法题综合性很强，结合了**二叉树遍历、堆、排序**等多个知识点。