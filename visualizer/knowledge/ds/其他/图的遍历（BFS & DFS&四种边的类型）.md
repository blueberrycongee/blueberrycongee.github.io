# 图 (Graph) - 遍历算法 (BFS & DFS)

### 1.1 邻接表查询边的复杂度

- **问题：** 在邻接表中判断边 $(u, v)$ 是否存在（`exists(u, v)`）。
    
- **有向图：** * 只需搜索 $u$ 的邻接表（出边表）。
    
    - 复杂度：$O(\text{degree}(u))$。
        
- **无向图：**
    
    - 可以搜索 $u$ 的邻接表，**或者** 搜索 $v$ 的邻接表。
        
    - **朴素复杂度：** $O(\max(\text{degree}(u), \text{degree}(v)))$。
        
    - **优化：并行搜索 (Parallel Search)**
> [!TIP] 什么是“并行搜索”？    
> 这里的“并行”**不是**指真正的多线程同时搜索，而是指**交替进行 (Alternating Search)**：
        > 
        > 1. 在 $u$ 的邻接表中查找 $v$（一步）。
        >     
        > 2. 在 $v$ 的邻接表中查找 $u$（一步）。
        >     
        > 3. 交替重复，直到在某一个表中找到为止。
        >     - **交替搜索复杂度：** 搜索会在较短的那个邻接表中先被完成。
        >     - 复杂度：$O(\min(\text{degree}(u), \text{degree}(v)))$。
            

### 1.2 邻接表查询优化：散列

- **思路：** 将每个顶点的邻接“表”（链表）替换为一个**散列表 (Hash Table)**。
    
- **实现：** $V[u]$ 指向一个散列表，存储所有 $u$ 的邻居。
    
- **复杂度：**
    
    - 判断边 $(u, v)$ 是否存在：$O(1)$（平均）。
        
    - 空间复杂度：如果装填因子控制在 50% 左右，总空间复杂度仍为 $O(n + e)$。
        
- **课程顺序：** 邓老师的课程已调整为先讲散列，再讲图，因此现在可以理解并使用这种优化。
    

---

## 2. 广度优先搜索 (BFS - Breadth-First Search)

### 2.1 BFS 核心思想

- **定义：** 也称“广度优先遍历”。
    
- **策略：**
    
    1. 访问起始顶点 $s$。
        
    2. 依次访问 $s$ 所有**尚未访问**的邻接顶点（第一代）。
        
    3. 依次访问第一代顶点的所有**尚未访问**的邻接顶点（第二代）。
        
    4. 以此类推。
        
- **类比：** 完全等同于**树的层次遍历 (Level-order Traversal)**。
    
- **产物：** BFS 会构造出原图的一棵**支撑树 (BFS Spanning Tree)**。
    

> [!WARNING] 代码与教材差异提醒
> 
> - 讲师提到，最新的 PPT/代码 与书上的代码在 `dTime`（发现时间戳）的处理上**不一致**。
>     
> - **最新代码：** `dTime` 是按“代”（generation）增加的。同一代（同一层）的顶点 `dTime` 相同。
>     
> - **书上代码：** `dTime` 可能是按访问顺序严格递增的。
>     
> - **重点：** 无论哪种实现，**BFS 的遍历访问顺序、边的分类、生成的支撑树结构是完全一致的**。
>     

### 2.2 BFS 算法与边的分类

- **数据结构：** **队列 (Queue)**。
    
- **算法流程 (单源)：**
    

C++

```
// BFS 算法逻辑 (C++ 风格伪代码)
void BFS(Graph& G, int s) {
    Queue<int> Q;
    G.setStatus(s, DISCOVERED); // 标记s为已发现
    Q.enqueue(s);

    while (!Q.isEmpty()) {
        int v = Q.dequeue();
        G.setDTime(v, ...); // (根据实现，设置dTime)

        for (int u : G.neighbors(v)) { // 考察v的每一个邻居u
            switch (G.getStatus(u)) {
                case UNDISCOVERED:
                    // u 尚未被发现
                    G.setStatus(u, DISCOVERED); // 发现u
                    G.setEdgeType(v, u, TREE);  // (v, u) 是树边
                    G.setParent(u, v);
                    Q.enqueue(u);
                    break;
                case DISCOVERED:
                case VISITED:
                    // u 已被发现(在队列中) 或 已访问完毕(已出队)
                    G.setEdgeType(v, u, CROSS); // (v, u) 是跨边
                    break;
            }
        }
        G.setStatus(v, VISITED); // v 访问完毕
        G.setFTime(v, ...); // (设置fTime)
    }
}
```

- **BFS 边的分类：**
    
    1. **树边 (Tree Edge)：** 发现尚未访问的顶点时所经过的边。
        
    2. **跨边 (Cross Edge)：** 连接到已发现或已访问顶点的边。
        
- **示例 (s -> a, c, d):**
    
    1. `s` 进队，出队。发现 `a, c, d`。`a, c, d` 进队。`(s,a), (s,c), (s,d)` 为树边。
        
    2. `a` 出队。发现 `e`。`e` 进队。`(a,e)` 为树边。`a` 的邻居 `c` 已在队列中 (`DISCOVERED`)，`(a,c)` 为跨边。
        
    3. `c` 出队。发现 `b`。`b` 进队。`(c,b)` 为树边。`c` 的邻居 `s` 已 `VISITED`，(无需处理)。
        
    4. `d` 出队。邻居 `b` 已在队列中 (`DISCOVERED`)，`(d,b)` 为跨边。
        
    5. ...以此类推...
        

### 2.3 BFS 完整遍历 (处理非连通图)

- **问题：** 如果图不是连通的，从 $s$ 出发的一次 `BFS(s)` 无法访问所有顶点。
    
- **策略：** 提供一个“外壳”函数 `bfs(G)`，它迭代所有顶点。
    
- **流程：**
    
    1. 初始化所有顶点为 `UNDISCOVERED`。
        
    2. `for (int s = 0; s < G.vertexCount(); s++)`
        
    3. `if (G.getStatus(s) == UNDISCOVERED)`
        
    4. `BFS(G, s);` // 对每个连通分量/可达分量执行一次
        
- **产物：** 这样会生成一个 **BFS 森林 (BFS Forest)**。
    

### 2.4 BFS 复杂度分析 (基于邻接表)

> [!IMPORTANT] 复杂度前提：基于邻接表 (Adjacency List)
> 
> 讲师强调，若使用邻接矩阵，复杂度会不同。

1. **初始化：** $O(n + e)$。需要将 $n$ 个顶点和 $e$ 条边的状态设为初始值。
    
2. **遍历 (小 `BFS(s)`)：**
    
    - **顶点：** 每个顶点最多进队一次、出队一次。$O(n)$。
        
    - **边：**
        
        - 有向图：每条边 $(v, u)$ 仅在 $v$ 出队时被考察一次。$O(e)$。
            
        - 无向图：每条边 $(v, u)$ 被考察两次（$v$ 出队时看 $u$，$u$ 出队时看 $v$）。$O(2e) = O(e)$。
            
3. **总复杂度：** $O(n) + O(e) = O(n + e)$。
    

### 2.5 BFS 的性质 (真题考点)

> [!CHECK] 重点：BFS 性质（真题考过判断题）
> 
> 1. **边分类：** BFS 只产生**树边**和**跨边**。
>     
> 2. **森林：** BFS 遍历全图将生成一个 BFS 森林。若图有 $c$ 个连通分量，则森林含 $c$ 棵树，有 $n - c$ 条树边和 $e - (n - c)$ 条跨边。
>     
> 3. 队列性质 (核心)：
>     
>     * 在 BFS 过程中，队列中的顶点按其到起点 $s$ 的距离 $d[s]$ 单调非降（Monotonically Non-decreasing）排列。
>     
>     * 队列中相邻顶点的 $d[s]$ 相差最多为 1。
>     
>     * 队列中队首和队尾顶点的 $d[s]$ 相差最多为 1。（最多只可能同时包含第 $k$ 代和第 $k+1$ 代的节点）。
>     
> 4. **树边性质：** 对于树边 $(v, u)$（$v$ 是 $u$ 的父亲），**恰好** $d[u] = d[v] + 1$。
>     
> 5. **跨边性质：** 对于跨边 $(v, u)$，它们的距离 $d[s]$ **至多相差 1**，即 $|d[v] - d[u]| \le 1$。（可能为 0，如兄弟节点间；也可能为 1）。
>     

---

## 3. 深度优先搜索 (DFS - Depth-First Search)

### 3.1 DFS 核心思想

- **策略：** **"一条道跑到黑" / "一路走到底"**。
    
- **流程：**
    
    1. 访问顶点 $s$。
        
    2. 若 $s$ 尚有未被访问的邻居 $u$，则任取一个 $u$，从 $u$ 出发**递归**执行 DFS。
        
    3. （递归返回）
        
    4. 若 $s$ 所有邻居都已被访问，返回。
        
- **类比：**
    
    - **树：** 等效于**先序遍历 (Pre-order Traversal)**。
        
    - **复习：** 第一遍 `BFS`（过一遍）；第二遍 `DFS`（对难点深入挖掘）。
        

> [!EXAMPLE] 寻找手机的类比
> 
> - **BFS 方式：** 先看所有大平面（地面、桌面、床面、椅面）；再看第二层（抽屉、枕头下）；再看第三层（抽屉里的盒子）...
>     
> - DFS 方式： > 1. 桌子： 看桌面 $\to$ 看抽屉 $\to$ 看抽屉里的盒子... （直到“桌子”这条线索彻底查完）
>     
>     2. 床： 看床面 $\to$ 看枕头下 $\to$ 看床单下 $\to$ 看床底... （直到“床”这条线索彻底查完）
>     
>     3. ...
>     

### 3.2 DFS 算法、时间戳与边的分类

- **数据结构：** **递归 (Recursion)**（系统栈）。
    
- **时间戳 (Timestamps)：**
    
    - `dTime[v]`：顶点 $v$ 被**发现 (DISCOVERED)** 的时刻。
        
    - `fTime[v]`：顶点 $v$ **访问完毕 (VISITED)** 的时刻。
        
- **起点：** 书上 `dTime` 从 1 开始，但最新 PPT 和代码从 0 开始。**按 0 开始为准**（考试若考具体数值会说明）。
    

C++

```
// DFS 算法逻辑 (C++ 风格伪代码)
int clock = 0; // 全局时钟

void DFS(Graph& G, int v) {
    G.setStatus(v, DISCOVERED);
    G.setDTime(v, clock++); // v 被发现

    for (int u : G.neighbors(v)) { // 考察v的每一个邻居u
        switch (G.getStatus(u)) {
            case UNDISCOVERED:
                // u 尚未被发现
                G.setEdgeType(v, u, TREE);  // (v, u) 是树边
                G.setParent(u, v);
                DFS(G, u); // 递归深入
                break;
            case DISCOVERED:
                // u 已被发现，但尚未访问完毕 (u是v的祖先)
                G.setEdgeType(v, u, BACKWARD); // (v, u) 是后向边
                break;
            case VISITED:
                // u 已访问完毕 (u是v的...?)
                if (G.getDTime(v) < G.getDTime(u)) {
                    G.setEdgeType(v, u, FORWARD); // (v, u) 是前向边
                } else { // G.getDTime(v) > G.getDTime(u)
                    G.setEdgeType(v, u, CROSS);   // (v, u) 是跨边
                }
                break;
        }
    }
    G.setStatus(v, VISITED); // v 访问完毕
    G.setFTime(v, clock++); // v 访问完成
}
```

- **DFS 边的分类：**
    
    1. **树边 (Tree Edge)：** 递归过程中实际经过的边。
        
    2. **后向边 (Back Edge)：** 指向**祖先**（`DISCOVERED` 状态）的边。
        
    3. **前向边 (Forward Edge)：** 指向**后代**（`VISITED` 状态且 `dTime[v] < dTime[u]`）的边。
        
    4. **跨边 (Cross Edge)：** 指向**既非祖先也非后代**的顶点（`VISITED` 状态且 `dTime[v] > dTime[u]`）的边。
        

### 3.3 无向图的 DFS (特殊处理)

> [!WARNING] 无向图 DFS 的边分类问题
> 
> - **问题：** 无向边 $(v, u)$ 在算法中被视为两条有向边 $v \to u$ 和 $u \to v$。
>     
> - **场景：** 若 $v$ 发现了 $u$，则 $v \to u$ 是**树边**。当递归到 `DFS(u)` 时，$u$ 会考察 $v$。此时 $v$ 处于 `DISCOVERED` 状态（它是 $u$ 的父亲），算法会把 $u \to v$ 判为**后向边**。
>     
> - **结论：** 在无向图的 DFS 中，严格来说只有树边和后向边。
>     
> - **PPT 示例：** 讲师指出，PPT 中的无向图例子**忽略了**这种指向父亲的“平凡”后向边，只画出了指向更高祖先的后向边（如 `g -> f`），并且没有判别跨边。这是为了简化示例。
>     

- **示例 (a:0) -> (b:1) -> (c:2) -> (f:3) -> (h:4) -> (g:5) -> (j:6):**
    
    - `j` 访问完毕 (j: 6/7)，返回 `g`。
        
    - `g` 发现 `i` (i: 8)，`i` 发现 `d` (d: 9)。
        
    - `d` 访问完毕 (d: 9/10)，返回 `i`。
        
    - `i` 访问完毕 (i: 8/11)，返回 `g`。
        
    - `g` 考察邻居 `f`。`f` 状态为 `DISCOVERED`（是 `g` 的祖先）。`(g, f)` 是**后向边**。
        
    - `g` 访问完毕 (g: 5/12)，返回 `h`。...（以此类推）
        

### 3.4 有向图的 DFS (四种边)

- 有向图的 DFS 会完整展现所有四种边。
    
- **示例 (a:0) -> (b:1) -> (c:2):**
    
    - `c` 访问完毕 (c: 2/3)，返回 `b`。
        
    - `b` 访问完毕 (b: 1/4)，返回 `a`。
        
    - `a` 考察 `c`。`c` 状态 `VISITED`。比较 `dTime[a](0)` 和 `dTime[c](2)`。因 $0 < 2$，$a$ 是 $c$ 的祖先。`(a, c)` 是**前向边**。
        
    - `a` 考察 `f` (f: 5)。`f` 考察 `g` (g: 6)。
        
    - `g` 考察 `a`。`a` 状态 `DISCOVERED`。`(g, a)` 是**后向边**。
        
    - `g` 考察 `c`。`c` 状态 `VISITED`。比较 `dTime[g](6)` 和 `dTime[c](2)`。因 $6 > 2$，$g$ 和 $c$ 无祖先后代关系。`(g, c)` 是**跨边**。
        
    - ...
        

### 3.5 DFS 的性质 (考点)

1. **森林：** DFS 遍历全图生成一个 DFS 森林。
    
2. **括号引理 (Parenthesis Theorem)：**
    
    - 任意两个顶点 $u, v$ 的**活动窗口** `[dTime, fTime]` 只有两种关系：
        
    - **1. 嵌套 (Nesting)：**
        
        - $[dTime[u], fTime[u]] \subset [dTime[v], fTime[v]]$
            
        - 当且仅当 $u$ 是 $v$ 的**后代 (Descendant)**。
            
    - **2. 分离 (Disjoint)：**
        
        - $[dTime[u], fTime[u]]$ 和 $[dTime[v], fTime[v]]$ **完全没有交集**。
            
        - 当且仅当 $u$ 和 $v$ **没有祖先后代关系**（例如兄弟、堂兄弟）。
            

> [!QUESTION] 讨论：后向边的数量是否等于回路数？
> 
> - **答案：否 (No, not necessarily).**
>     
> - **理由：**
>     
>     1. 一条**后向边**（指向祖先）**一定**会构成一个回路。
>         
>     2. 但是，一个回路**不一定**只由后向边构成。它也可能由树边、前向边和跨边共同构成（特别是在有向图中）。
>         
> - **示例：**
>     
>     - $A \to B, A \to C, B \to D, C \to D, D \to A$。
>         
>     - 此图有两个回路：$A-B-D-A$ 和 $A-C-D-A$。
>         
>     - 若 DFS 路径为 $A \to B \to D$，则 $D \to A$ 是一条**后向边**（发现一个回路）。
>         
>     - 返回到 $A$，再 $A \to C$。$C \to D$ 时，$D$ 已 `VISITED`。比较 `dTime[C]` 和 `dTime[D]`，$C$ 的 `dTime` 更大，所以 $C \to D$ 是一条**跨边**（构成了第二个回路）。
>         
>     - 在此次 DFS 中，只找到 1 条后向边，但图中有 2 个回路。

