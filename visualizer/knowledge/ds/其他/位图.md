# 💻 计算机专业课深度笔记：向量（二）
## 🖼️ 位图（Bitmap）数据结构详解

### 1. 位图的定义与特点

- ​**定义：​**​ 位图是一种用于表示**非负整数**集合（大于等于 0）的数据结构。
    
- ​**核心思想：​**​ 对集合中的每一个数（元素），只用**一个比特位（Bit）​**来表示其**存在性**。
    
    - ​**包含：​**​ 对应比特位为 1 (True)。
        
    - ​**不包含：​**​ 对应比特位为 0 (False)。
        
    
- ​**特点：​**​
    
    - ​**无重复元素：​**​ 集合中不包含重复元素。多次加入同一个元素（`set`），效果等同于只加入一次。
        
    - ​**空间效率高：​**​ 相较于使用数组/向量存储元素本身，位图极大地节省了空间，因为它只需要 1 比特/元素。
        
    

### 2. 位图的三个核心接口（API）

|接口名称|描述|
|---|---|
|`test(k)`|​**判断**非负整数 k是否在集合中。|
|`set(k)`|​**将**非负整数 k​**加入**集合。若 k已在集合中，则不进行任何操作。|
|`clear(k)`|​**将**非负整数 k​**从**集合中**移除**。|

- ​**对比向量实现：​**​ 如果使用向量（`std::vector`）来实现上述集合功能，虽然可行，但会存在**复杂度高**​（如查找 O(N)）和**空间浪费**的问题。
    

### 3. 位图的存储与空间申请

- ​**最小存储单位：​**​ 在 C/C++ 中，最小的数组单位通常是 `char`类型，即 8 比特（一字节）。
    
- ​**空间申请策略：​**​ 无法精确申请到 N比特的空间，必须以字节为单位进行申请。
    
    - 如果需要存储 n个比特位（即支持 0到 n−1的非负整数），则所需字节数 N的计算公式为：
        
        $N=⌈8n​⌉=⌊8n+7​⌋$
        
    - 例如，需要 35 个比特位，则需要 ⌈35/8⌉=5个字节（共 40 比特），浪费 5 个比特位。
        
    
- ​**位图数组：​**​ 通常使用一个 `char`类型的数组 `B[]`或 `M[]`来存储位图数据。
    

### 4. 位图接口的底层实现（位运算）

位图的核心在于将数字 k映射到数组中的**特定字节**和该字节中的**特定比特位**。

- 对于任意非负整数 k：
    
    - ​**所在字节的索引（Index）：​**​ k/8(整除)。
        
    - ​**字节内的位偏移（Offset）：​**​ k(mod8)(取余)。
        
    

#### 4.1. `test(k)`实现

- ​**目的：​**​ 判断第 k个比特位是否为 1。
    
- ​**原理：​**​
    
    1. 确定 k所在的字节 M[k/8]。
        
    2. 构造一个**掩码（Mask）​**，该掩码仅在第 k(mod8)位上为 1。
        
    3. 将 M[k/8]与掩码进行**按位与 (&)​**​ 操作。
        
    
- ​**掩码构造：​**​
    
    - 使用十六进制数 `0x80`(二进制为 `1000 0000`) 作为起始，然后将其**右移**​ k(mod8)位。
        
    - k(mod8)的操作可以通过**按位与**​ k&0x07（其中 0x07对应二进制 `0000 0111`）来实现。
        
    
- ​**判断逻辑：​**​ 如果按位与结果**不为 0**​（即为 1），则 k在集合中，返回 True。
    

#### 4.2. 动态扩容（Resize/Expand）※

- 在执行 `test/set/clear`接口时，若访问的位图索引超出当前分配的空间（出界），则需要进行**扩容**操作。
    

---

## 💡 位图的典型应用

### 应用一：小集合大数据去重（Small Set, Big Data）

- ​**问题描述：​**​ 给定一个包含 N个元素的向量 A，其中所有元素取值范围均在 [0,M)内（M远小于 N），要求**剔除**所有相等者（即**无序向量去重**）。
    
    - ​**特点：​**​ N很大（如十亿），M相对较小（如 224），意味着重复元素**非常多**。
        
    
- ​**传统排序方案（作为对比）：​**​
    
    1. 先对 A排序：时间复杂度 O(NlogN)。
        
    2. 再进行有序向量去重：时间复杂度 O(N)。
        
        - ​**总时间：​**​ O(NlogN)。
            
        - ​**弊端：​**​ N很大时，可能面临**内存不足**​（无法一次性申请到足够的内存）和**频繁 I/O**​ 导致的效率低下（需要外部排序）。
            
        
    
- ​**位图解决方案：​**​
    
    1. ​**初始化位图：​**​ 申请一个位图 B，其大小与数据范围 M对应（支持 0到 M−1的整数）。
        
    2. ​**设置（Set）阶段：​**​ 遍历输入向量 A中的 N个数（A[i]），对每个数执行 `B.set(A[i])`。
        
        - ​**作用：​**​ 重复的元素不会对位图产生额外影响。
            
        - ​**时间复杂度：​**​ O(N)。
            
        
    3. ​**提取（Extract）阶段：​**​ 遍历位图 B的所有 M个可能值（k从 0到 M−1），对每个 k执行 `B.test(k)`。
        
        - ​**作用：​**​ 将所有被 `set`过的数（即去重后的元素）提取出来。
            
        - ​**时间复杂度：​**​ O(M)。
            
        - ​**总时间复杂度：​**​ ​**​O(N+M)​**。
            
        
    
- ​**效率对比：​**​ O(NlogN)→O(N+M)。由于 M≪NlogN，该算法将时间复杂度**压低了 logN倍**，效率提升显著。
    
- ​**非整数情况（例如：搜索关键字）：​**​
    
    - 如果输入数据不是整数（例如字符串、关键字），则不能直接使用位图。
        
    - ​**解决方案：​**​ 需要将非整数数据通过**散列函数（Hash Function）​**转化为整数。
        
    - ​**相关知识：​**​ 散列（Hash）技术可以解决位图能解决的所有问题，但在纯整数且 M较小时，位图更节省空间。
        
    

### 应用二：埃拉托斯特尼筛法（Sieve of Eratosthenes）求素数

- ​**目的：​**​ 计算不超过 N的所有素数（质数）。
    
- ​**核心思想（筛法）：​**​
    
    1. 从 2 开始，2 是素数。
        
    2. 将 2 的所有**倍数**标记为非素数（"扎眼"）。
        
    3. 找到下一个未被标记的数，它一定是素数（如 3）。
        
    4. 将 3 的所有倍数标记为非素数。
        
    5. 重复此过程，直到遍历到 N​即可。
        
    
- ​**位图的应用：​**​ 使用位图 B存储 0到 N的所有数，`B.set(k)`表示 k​**不是**素数。
    
- ​**算法优化（内循环起点）：​**​
    
    - 内循环（标记倍数）的起点可以从 i2开始，而非 2i。
        
    - ​**原理：​**​ 任何小于 i2且是 i的倍数的合数 k（即 k<i2且 k=i⋅m,m<i），一定已经在以小于 i的素数（如 m）为基准的筛查中被标记过了。
        
        - 例如：7 的 2 倍 (14) 在 2 的倍数筛查中被标记；7 的 3 倍 (21) 在 3 的倍数筛查中被标记。
            
        
    
- ​**时间复杂度分析：​**​
    
    - ​**朴素分析（二重循环）：​**​ 看起来像 O(N2)，但实际上不是。
        
    - ​**基于素数定理（Prime Number Theorem）：​**​
        
        - N以内的素数个数 π(N)，当 N→∞时，有 N/lnNπ(N)​≈1。
            
        - 外循环只遍历**素数**。
            
        - ​**算法时间复杂度：​**​ 最终渐进时间复杂度为 ​**​O(NloglogN)​**​（而不是 O(NlogN)）。
            
        
    
- ​**渐进性改进：​**​ 将内循环起点改为 i2仅改进了**常系数**，​**渐进意义上的复杂度没有改变**。
    

---

## 📌 习题解析与考点回顾

### 1. 复杂度分析与算法比较

|算法|复杂度类型|结论|
|---|---|---|
|​**迭代版二分查找**​（Binary Search）|空间复杂度|O(1)。|
|​**递归版二分查找**​|空间复杂度|不是 O(1)（因递归调用栈）。|
|​**归并排序**​|空间复杂度|非 O(1)（因递归调用栈）。|

### 2. 斐波那契查找（Fibonacci Search）的轴点选择

- ​**查找过程：​**​ 基于斐波那契数列 Fk​=Fk−1​+Fk−2​来确定分割点（轴点）。
    
- ​**轴点位置：​**​ 轴点 k−1满足整个向量长度 N=Fk​−1。
    
    - ​**特点：​**​ 轴点通常是**中间偏右**的元素。
        
    
- ​**举例分析（找 1）：​**​ 向量 ⟨1,2,3,4,5,6,7⟩，长度 N=7。
    
    - ​**​N=7：​**​ 不大于 7 的最大斐波那契数 Fk​=5。
        
    - ​**第一次比较：​**​ 轴点在**第 5 个数**​（从 1 开始计数）。即与元素 ​**5**​ 比较。
        
    - ​**第二次比较：​**​ 查找左侧子向量 ⟨1,2,3,4⟩，长度 N′=4。不大于 4 的最大斐波那契数 Fk′​=3。轴点在**第 3 个数**。即与元素 ​**3**​ 比较。
        
    - ​**第三次比较：​**​ 查找左侧子向量 ⟨1,2⟩，长度 N′′=2。不大于 2 的最大斐波那契数 Fk′′​=2。轴点在**第 2 个数**。即与元素 ​**2**​ 比较。
        
    - ​**第四次比较：​**​ 查找左侧子向量 ⟨1⟩，长度 N′′′=1。不大于 1 的最大斐波那契数 Fk′′′​=1。轴点在**第 1 个数**。即与元素 ​**1**​ 比较。
        
    - ​**比较元素序列：​**​ 5, 3, 2, 1。
        
    

### 3. 归并操作中的比较序列

- ​**操作：​**​ 将 ⟨2,5,7⟩和 ⟨3,11,13⟩归并。
    
- ​**比较序列：​**​
    
    1. 2vs 3→选 2。
        
    2. 5vs 3→选 3。
        
    3. 5vs 11→选 5。
        
    4. 7vs 11→选 7。
        
    
- ​**序列：​**​ 2和 3；5和 3；5和 11；7和 11。
    

### 4. 冒泡排序（Bubble Sort）的特性

- ​**问题：​**​ 冒泡排序**任何一趟扫描**中，最后一次交换是将 x>y换成 y,x之后，能够确定什么？
    
- ​**结论：​**​ 能够确定 x​**必然已经就位**。
    
    - ​**解释：​**​ 冒泡排序的每一趟扫描都会将**当前未排序部分中的最大元素**移动到其最终正确的位置（即**数组末尾**）。
        
    - ​**最后一次交换**​：发生最后一次交换的 x必然是**当前趟扫描结束时位于末尾的元素**，它就是该趟扫描所能确定的最大元素，因此它已经**就位**。
        
    - ​**​y的位置：​**​ y换到 x的位置后，其位置**不一定正确**。
        
    

---

## 📚 考点与深入学习建议

- ​**位图考点：​**​ ​**非重点**。在 826 真题中尚未出现过位图相关的考题。
    
- ​**建议自学内容（PPT 后面部分）：​**​ 位图初始化 O(N)→O(1)的优化思路、校验环等。
    
    - 可参考**学堂在线**和**习题解析 2-34**​ 中的详细讲解。
        
    
- ​**考试趋势（知识点难度分布）：​**​ 简单题通常集中在**判断题**或部分**选择题**，但分数占比不高。填空题通常更值钱，难度也相对较高。