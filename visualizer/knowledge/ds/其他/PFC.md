# 核心概念与直觉

- **前缀码（PFC）**：任一码字都不是另一码字的前缀 ⇒ **可即时解码、无歧义**。
    
    - 反例直觉：若 `s→11`、`m→111`，收到`111`会歧义（`s s s`还是`m` ` m` ）。
        
    - 生活类比：用**汉语拼音**直接串接会有分词歧义（如“xi an”可能是“西安”或“鲜”的一部分）；而规范的二进制前缀码不会。
        
- **码树表示**：二叉树上**左=0，右=1**（约定即可）。**码字只能放在叶子**，不能把内部节点当成码字，否则会造成解码歧义。
    
- **不做“无谓浪费”**：虽可人为让某些内部边“不承载信息”、硬把码字放更深（如给 `a` 配很长码并让中间结点都空着），但这只会**增大平均码长**，标准题目默认排除这种“浪费”。
    
---

# 平均码长与“带权平均深度”

- **无权情形**：平均码长 = 叶节点**平均深度**。
    
- **带权情形**：$设字符集合 {ci}\{c_i\} 的出现概率为 pip_i，码长为 ℓi\ell_i，目标是最小化$
    
    $L=∑ipi ℓiL = \sum_i p_i \,\ell_i$
    
    ——这就是**带权平均码长**（或“叶子带权平均深度”）。
    
- **设计原则**：**高频字符码字要尽量短，低频字符码字可以长**。你用“m、a 频率更高时让其更短”的示例说明了这一点（“mamma mia”等例子里，总码长可明显降低）。
    

---

# 哈夫曼编码（重点、必考）

## 算法（贪心思路）

1. 对每个字符建一棵只含一个叶子的树（权值=频率/概率），形成**森林**。
    
2. 反复**取权值最小的两棵树**合并为新树（新根权值=两子树之和），直到只剩一棵。
    
3. 从根到叶将左/右边标为 0/1，即得码字。
    

> 实现要点与复杂度
> 
> - 朴素：每次从有序序列中取两最小再插回，**O(n²)** 或 **O(n log n)**（视维护结构而定）。
>     
> - **最小堆/优先队列**：建堆 O(n)，每次合并取两最小并插入，整体 **O(n log n)**。
>     
> - **预排序 + 两队列**：先按权值排序，再用两队列归并式取最小，也可实现**接近 O(n)** 的合并流程（课程常见技巧）。
>     

## 正确性与贪心

- 哈夫曼属于**能保证全局最优**的贪心法（教材与《算法导论》给出证明思路）。
    
- 但你也提醒：**贪心并非总能解所有问题的最优解**；能否最优需满足特定结构（如拟阵等）。
    

## 性质（你课上都提到了）

- **前缀码/即时解码**：由构造即得，无前缀关系。
    
- **树形态**：**每个内部节点都有两个孩子**（满二叉/proper binary）。若出现度为1的内部节点，可把它与唯一孩子“收缩”而不劣化，从而改进。
    
- **层次性（哈夫曼性质）**：**权值最小的两个叶子必为某棵最优码树的兄弟，且在最底层**。
    
- **不唯一性**：
    
    - 左右子树互换不变；
        
    - 若有**相等权值**，**合并顺序**也有多种选择 ⇒ **码树/码本不唯一**。
        
    - 考试题会问“共有多少棵哈夫曼树”这类计数问题（等权并列时尤其多解）。
        
- **（在特定等权示例中）叶子仅出现在倒数两层**
    

## 重要反例（你专门举了）

- **“最优带权编码树不一定是哈夫曼树”**：例如权值为 **1,2,3,3** 的四字符集，可构造一棵**满二叉且四叶等深**的最优树（所有码长均为2，带权平均码长与某些哈夫曼构造相同），但它**不是**按“先合并 1 与 2”的哈夫曼步骤生成的那一棵。这说明：
    
    - **哈夫曼树一定最优**；
        
    - **最优带权编码树不一定“长得像”某次具体运行的哈夫曼构造**（存在同最优的非哈夫曼形态）。
        

---

# 例题要点与解题技巧（你讲到/提示过的）

- **判定前缀码**：检查是否有码字是另一码字的前缀（或看码树是否把码字放在内部节点）。
    
- **算平均码长**：给出码长或码树，计算叶深度或按频率加权求和。
    
- **构造最优码**：已知频率，按哈夫曼合并（会手算）。
    
- **不唯一性/计数**：当存在相等权值或对称结构时，统计不同合并/左右交换的可能。
    
- **等概率小集合设计**：对 4 个等概率符号，最优是**满二叉两层叶**（码长全为2）；给出的某些“左/右方案”可通过**比较总码长**判优劣。
    
- **“mamma mia”类串**：根据给定码本把串编码，或反向解码并统计总位数（你举例中“右边方案总码长更短”，如从 15 降到 13 的直观对比）。
    

---

# 树与图的拓展（本节你也提到）

- **树的直径 Diameter**：任意两点间最远距离（边数/权和）。
    
    - **不一定经过根**（易被直觉误导）。
        
    - **线性时间 O(n) 算法**：从任一点做 BFS/DFS 找到最远点 uu，再从 uu 做一次 BFS/DFS 得到最远点 vv，距离 d(u,v)d(u,v) 即直径。（课上说“两次 BFS/DFS 皆可”。）
        
- **偏心率/中心**：
    
    - 节点偏心率 = 它到最远点的距离；
        
    - 树中心 = 使最大距离最小的点（1 个或 2 个）。
        
- **比较排序下界**：用**二叉决策树**证明下界为 **Ω(n log n)**（教材页码索引到“邓书 59 页”一带）。
    
- **规约（Reduction）**：你提到书中有，但历年题很少直接考；可参考《算法导论》对应章节。
    

---

# 实现与工程化提示

- **基础实现**：排序 + 顺次合并。
    
- **更优实现**：最小堆（优先队列）维护“当前最小两棵树”，整体 **O(n log n)**。
    
- **预排序 + 两队列**：把“已合并结果队列”和“未合并已排序队列”做**归并式**取最小，简化实现、效率更稳。
    
- **数据结构**：需要能表达“节点权值、左右子、是否叶子（存字符）”。
    

---

# 教学与考务提醒

- 本章偏**小题**为主，但也可能出现**构造/重建**等大题（如用先序+后序确定层次序的证明题）。
    
- **哈夫曼几乎年年考**：平均码长计算、性质（前缀/不唯一/叶在底层/兄弟性等）、手工构造最优码常见。
    
- 课堂节奏：本节讲完哈夫曼，随后会发**10 道练习题**，预留约 **15 分钟**做题，再集中讲解收尾，二叉树章结束。
    

---

# 一页备忘（Quick Sheet）

- **前缀码**：码字只在**叶**；任一码字都不是另一码字前缀。
    
- **目标**：最小化 $∑piℓi\sum p_i \ell_i。$
    
- **哈夫曼**：每次合并**最小两权**；内部节点度为2；两最小权叶是**兄弟且在底层**；**不唯一**（等权/对称/左右互换）。
    
- **实现**：最小堆 O(nlog⁡n)O(n \log n)；或预排序 + 两队列。
    
- **常错**：把内部节点当码字；忘记带权；未验证前缀性；以为直径必经根。
    
- **图论补充**：树直径=两次 BFS/DFS；比较排序下界 Ω(n log n)。
    