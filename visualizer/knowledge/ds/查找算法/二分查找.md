# 二分查找（C++实现）

## 1. 基本概念

二分查找（Binary Search）是一种在有序数组中查找特定元素的高效算法。通过反复将查找区间对半分割，将查找时间复杂度降低到对数级别。

## 2. 前提条件

1. 必须是有序序列（升序或降序）
    
2. 支持随机访问
    
3. 可比较大小关系
    

## 3. 时间复杂度

- 最好情况：O(1) - 中间元素就是目标
    
- 最坏情况：O(log n)
    
- 平均情况：O(log n)
    

## 4. 三种版本实现

### 4.1 基础版本

```cpp
int binarySearchA(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

### 4.2 左边界查找

找到第一个大于等于target的位置

```cpp
int binarySearchB(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

### 4.3 右边界查找

找到最后一个小于等于target的位置

```cpp
int binarySearchC(vector<int>& arr, int target) {
    int left = -1, right = arr.size() - 1;
    while (left < right) {
        int mid = left + (right - left + 1) / 2;
        if (arr[mid] <= target) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
```

## 5. 查找长度的计算

平均查找长度（ASL）：

- 成功查找：ASL ≈ log₂(n+1) - 1
    
- 失败查找：ASL ≈ log₂(n+1)
    

### 5.1 具体计算方法

对于n个元素的有序表：

- 第1层：1个元素，比较1次
    
- 第2层：2个元素，比较2次
    
- 第k层：2^(k-1)个元素，比较k次
    
- 树高h = ⌈log₂(n+1)⌉
    

## 6. 斐波那契查找（Fibonacci Search）

利用斐波那契数列的特性进行查找：

- 将数组分割成斐波那契数列的两部分
    
- 类似二分查找，但分割点不是中点
    
- 优势：只用加减法，避免除法运算
    

```cpp
// 需要先预先生成斐波那契数列
int fibonacciSearch(vector<int>& arr, int target) {
    int n = arr.size();
    
    // 生成斐波那契数列直到F(k) >= n
    vector<int> fib = {0, 1};
    while (fib.back() < n) {
        fib.push_back(fib[fib.size()-1] + fib[fib.size()-2]);
    }
    
    int k = fib.size() - 1;
    int low = 0;
    int high = n - 1;
    
    while (low <= high) {
        int mid = low + fib[k-1] - 1;
        if (mid > high) mid = high;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
            k -= 2;
        } else {
            high = mid - 1;
            k -= 1;
        }
    }
    
    return -1;
}
```

## 7. 相关主题

- 基于比较的算法（Comparison-Based Algorithm）
    
- 顺序查找 - 基础查找方法
    
- 插值查找 - 改进的二分查找
    
- 二叉搜索树（BST） - 二分思想的树形结构
    

## 8. 常见陷阱

1. 整数溢出：`mid = (left + right) / 2`可能溢出
    
    - 改进：`mid = left + (right - left) / 2`
        
    
2. 边界条件：注意 `left <= right`vs `left < right`
    
3. 更新条件：`left = mid + 1`vs `left = mid`
    
4. 右边界查找中的中间值计算：`mid = left + (right - left + 1) / 2`