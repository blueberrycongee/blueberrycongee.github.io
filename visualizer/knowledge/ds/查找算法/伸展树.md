# 伸展树（Splay Tree）

---

## 1. 核心思想与基本操作

- **核心行为**：当访问到结点 $v$（查找/插入/删除中的关键结点）后，**通过旋转把 $v$ 伸展到根**。
    
- **目的**：利用**局部性原理**（时间/空间局部性），让**近期常用**的结点靠近根，后续再访问更快——**自适应**数据结构。
    

---

## 2. 两种伸展方式：单层 vs 双层（默认双层）

### 2.1 单层伸展（逐个上调，非标准）

- **算法**：从 $v$ 出发，每次只与父 $p$ 旋转一次（Zig 或 Zag），反复直到 $v$ 成为根。
    
- **问题**：性能高度依赖初始形态与访问序列；对**单链 + 顺序扫描**等场景，**每周期累计 $\Theta(n^2)$**，**分摊 $\Theta(n)$** → 不可用。
    

### 2.2 双层伸展（标准 splay，考试默认）

每一轮看三代 $g$-$p$-$v$：

1. **Zig-Zig（同向，一字形）**：$v$ 与 $p$ 同为左（或同为右）  
     操作：先围绕 **$g$** 旋，再围绕 **$p$** 旋（如 zig(g)→zig(p)，或镜像 zag(g)→zag(p)）。
    
2. **Zig-Zag（异向，之字形）**：$v$ 与 $p$ 左右相反  
     操作：先围绕 **$p$** 旋，再围绕 **$g$** 旋（如 zig(p)→zag(g)，或镜像 zag(p)→zig(g)）。
    
3. **父已是根（最后一步）**：只做一次 **Zig/Zag**。
    

**效果**：路径强力压缩；**最坏不至持续发生** → **分摊 $O(\log n)$**。

> **默认规则**：题目未指明“单层/双层”，一律按**双层**回答，分摊 **$O(\log n)$**。

---

## 3. 效率与复杂度（重中之重）

### 3.1 分摊复杂度

- **总体结论**：伸展操作**分摊 $O(\log n)$**，与 AVL/RB 同阶（分摊意义上属于 BBST）。
    

### 3.2 顺序访问（单链 + $1..n$ 循环）

- **单层**：每周期累计 $\Theta(n^2)$ ⇒ 分摊 $\Theta(n)$（极差）。
    
- **双层**：访问早期树高迅速下降（约 $n/2,, n/4,,\dots$），虽然后续可能再次变高，但**最坏形态出现频度低**，总账**分摊 $O(\log n)$**；更强定理见 §7.4。
    

### 3.3 局部性与工作集

- 若连续访问仅在 **$k\ll n$** 个键内反复出现，**分摊 $O(\log k)$**；极强局部性时**近 $O(1)$**。
    
- 对任意连续 **$m$** 次访问：**总成本 $O(m\log k+n\log n)$**，当 $m\to\infty$ 时的分摊即 $O(\log k)$。
    

### 3.4 单次最坏

- 仍可能 **$\Theta(n)$**（如从根沿着链最远端访问一次）。因此**硬实时/强单次时延约束场合**不宜选用 splay。
    

---

## 4. 插入与删除（两套写法）

### 4.1 直观写法（Bottom-Up）

- **插入**：按 BST 插入后，**splay 新结点到根**。
    
- **删除**：**splay 待删键到根**，将根的左右子树 **join** 起来。
    

### 4.2 优化写法：**Split / Join**（推荐）

- split(T, key)：把 $T$ 分成 $TL(<key)$ 与 $TR(\ge key)$（先 splay 到“$\le key$ 最近”，再断开）。
    
- join(TL, TR)：要求 $\max(TL) < \min(TR)$；splay $TL$ 最大键到根，令 $root.right=TR$。
    
- **插入**：先 split，令新结点为根，左接 $TL$、右接 $TR$。
    
- **删除**：splay 待删键到根，join(root.left, root.right)。
    

---

## 5. 势能法与访问引理（Amortized Analysis）

### 5.1 势能函数（等权版常用）

- 定义：  
    $\Phi(T)=\sum\limits_{v\in T}\log s(v)$，其中 $s(v)$ 为以 $v$ 为根的子树规模。
    
- 形态估计：
    
    - **单链**：$\Phi=\log(n!)=\Theta(n\log n)$。
        
    - **近满树**：$\Phi$ 更小。
        

### 5.2 访问引理（加权更一般）

给每键权 $w(x)>0$，记 $S=\sum w$。设 $s(v)=\sum_{u\in \text{subtree}(v)} w(u)$，  
势能 $\Phi=\sum\log s(v)$。把 $x$ 伸展到根的**分摊**代价：

$O~ ≤ 3(log⁡S−log⁡w(x))+O(1).\tilde{O}\ \le\ 3\big(\log S-\log w(x)\big)+O(1).$

- 等权 $w\equiv 1$ ⇒ $S=n$ ⇒ **分摊 $O(\log n)$**。
    
- 结合合适的权选择，可推出 §6 中的多种性质。
    

---

## 6. 四大经典性质（进阶必备）

1. **静态最优性（Static Optimality）**  
    长期访问权重 $w(x)$ 已知的“静态最优 BST”之总代价，与 splay 的总代价**同阶**。
    

> 直观：频繁键会被自动拉近根，不逊于“预知频率再构树”。

2. **工作集性质（Working-Set）**  
    访问 $x$ 的分摊代价为 $O(\log t(x))$，其中 $t(x)$ 为自上次访问 $x$ 起被访问过的**不同**键数。
    

> 直接推出“在 $k$ 个热键内反复访问 ⇒ 分摊 $O(\log k)$”。

3. **动态手指性质（Dynamic Finger）**  
    连续访问 $i\to j$ 的分摊代价为 $O!\big(\log(\text{rank-dist}(i,j)+1)\big)$。
    

> 与上一次访问的秩更近 ⇒ 更快。

4. **顺序扫描定理（Sequential Access）**  
    从任意初始树按键值递增访问 $1,2,\dots,n$ 的**总**代价是 **$O(n)$**。
    

> 强于一般分摊界，解释了“顺序遍历总账线性”的现象。

---

## 7. 实现要点（伪码/套路）

### 7.1 自底向上 splay（父指针版）

text
rotate(p):        // 将 p 的子 v 旋上来：Zig 或 Zag
  // 标准 BST 旋转：维护祖父链接与左右子指针

splay(v):
  while parent(v) != null:
    p = parent(v); g = parent(p)
    if g == null:                // Zig
      rotate(p)
    else if (v 与 p 在 g 同侧):  // Zig-Zig
      rotate(g); rotate(p)
    else:                        // Zig-Zag
      rotate(p); rotate(g)


### 7.2 自顶向下 splay（Top-Down，工程常用）

- 维护两棵临时树 L/R 及游标 lt/rt；边走边根据大小关系**小旋**并把“小于的挂 L，大于的挂 R”，结束后把 L、R 拼回。
    
- **优点**：无需父指针、cache 友好、代码简洁（高频推荐）。
    

### 7.3 Split / Join（插删搭配）

见 §4.2。考场画图题/代码题都很实用。

---

## 8. 常见题型与速解策略

1. **判断/选择**
    

- “伸展树分摊复杂度？”→ **$O(\log n)$**（默认双层）。
    
- “有局部性（$k$ 个热键）？”→ **分摊 $O(\log k)$**，强局部性可近 **$O(1)$**。
    
- “顺序遍历 $1..n$ 总复杂度？”→ **$O(n)$**（顺序扫描定理）。
    

2. **画树题**
    

- **初始单链 + 访问最深叶一次**：把该叶 splay 到根；其原路径上的相对次序根据 Zig-Zig/Zig-Zag 重连。
    
- 速解：**三代定位 + 两次旋**；父/祖父链接、左右子指针**不断、简洁、准确地更新**。
    
- **访问短序列**（如 $3,1,4,1,5$）：每步都把被访者画到根；留意上一轮根常成为其左/右子，旋转方向据秩判断。
    

3. **势能题**
    

- 试题常**给出势能定义**，让你算“前后势能差”＋“实际旋转代价”＝“分摊代价”。
    
- 单链势能 $\log(n!)$ 与 $n\log n$ 同阶，作为上界估算即可。
    

---

## 9. 易错点清单（考场避坑）

- 把**单层**当标准 ⇒ 所有分摊结论**作废**；务必按**双层**。
    
- 误以为“树只能越来越矮” ⇒ 错。应答：“**最坏不至持续发生**，分摊界成立”。
    
- 插删未用 **split/join**，或旋转时**祖父链接/子指针**更新不全。
    
- 把“分摊等同单次” ⇒ 错。**单次最坏 $\Theta(n)$**。
    
- 题面未明示仍写“单层”或忘记写复杂度口径（**$\log$ 的底数无关**，写 $\log$ 即可）。
    

---

## 10. 与其他树的对比（补丁后的对照表）

|特性|伸展树|AVL|红黑树|
|---|---|---|---|
|平衡保证|不显式维护（自适应）|严格平衡|弱平衡|
|单次最坏|**$O(n)$**|$O(\log n)$|$O(\log n)$|
|分摊复杂度|**$O(\log n)$**|$O(\log n)$|$O(\log n)$|
|局部性收益|**$O(\log k)$/近 $O(1)$**|仍 $O(\log n)$|仍 $O(\log n)$|
|元数据|**$0$**|平衡因子|颜色/黑高|
|顺序遍历总账|**$O(n)$**|$O(n\log n)$|$O(n\log n)$|
|适用|访问分布未知/多变、强局部性|稳定单次上界|工程稳健性、库实现|

---

## 11. 工程选型建议

- **强局部性/工作集小/少元数据需求**：选 **splay**。
    
- **单次时延敏感（硬实时/关键控制）**：倾向 **AVL / 红黑**。
    
- **大量顺序遍历**：splay 享受 **$O(n)$** 总账。
    

---

## 12. 进阶性质提示（面试/竞赛常问）

- 通过恰当权设定与**访问引理**，可推出**静态最优、工作集、动态手指**等性质。
    
- **Top-Down splay** 在工程上更常用（无父指针、实现短、cache 友好）。
    

---

## 13. 相关主题（复习导航）

- 比较模型与决策树下界
    
- BST 基础、AVL、红黑、Treap、Scapegoat
    
- 摊还分析：**势能法**、银行家方法
    

---

## 14. 典型应用（举例）

- 自适应字典/符号表、**近似 LRU** 的访问偏好结构
    
- 交互式/在线算法中访问分布未知、随时间漂移的索引
    
- 某些内存管理/垃圾回收阶段性热区的指针目录（视实现而定）
    

---

## 15. 速查卡（Cheat Sheet）

**操作**：访问/插入/删除 ⇒ **把目标 splay 到根**；每轮看 $g$-$p$-$v$：

- **Zig-Zig**：同侧，两次围绕 **$g$**、**$p$**；
    
- **Zig-Zag**：异侧，先 **$p$** 后 **$g$**；
    
- **父是根**：一次 **Zig**。
    

**复杂度**：

- 一般：**分摊 $O(\log n)$**；
    
- 工作集 $k$：**分摊 $O(\log k)$**；
    
- 顺序 $1..n$ 总账：**$O(n)$**；
    
- 单次最坏：**$\Theta(n)$**。
    

**插删套路**：split / join（推荐），或“BST 插入＋splay 新结点到根；splay 待删键到根＋join”。

**答题默认**：未说明一律**双层 splay**（非单层）。

---

## 16. 附：迷你伪码（Top-Down 思路，便于实作）

text
// Top-Down Splay 找 key 并把“最后访问到的”结点旋到根
splay(T, key):
  if T == null: return null
  L = R = null; lt = rt = null
  cur = T
  while true:
    if key < cur.key:
      if cur.left == null: break
      if key < cur.left.key:           // Zig-Zig：右旋 cur
        cur = rotateRight(cur)         // 把更小的拉上来
        if cur.left == null: break
      // 连接到 R 树
      if R == null: R = cur; rt = cur
      else: rt.left = cur; rt = cur
      cur = cur.left
      rt.left = null
    else if key > cur.key:
      if cur.right == null: break
      if key > cur.right.key:          // Zag-Zag：左旋 cur
        cur = rotateLeft(cur)
        if cur.right == null: break
      // 连接到 L 树
      if L == null: L = cur; lt = cur
      else: lt.right = cur; lt = cur
      cur = cur.right
      lt.right = null
    else:
      break
  // 拼回
  if L != null: lt.right = cur.left; cur.left = L
  if R != null: rt.left  = cur.right; cur.right = R
  return cur  // 新根


> split/join/insert/erase 可在此基础上 20~40 行内完成。  
> 题目若考“画树”，按 **三代定位＋两次旋**，每步维护父/祖父与左右子指针。

---

### 最后提示（考场答题口径）

- **一律默认双层 splay**；
    
- 复杂度题回答**分摊 $O(\log n)$**／**工作集 $O(\log k)$**／**顺序 $O(n)$**；
    
- 单次最坏**$\Theta(n)$**别忘记；
    
- 画树按 **Zig-Zig / Zig-Zag** 逐轮画；
    
- 势能题会**给出 $\Phi$**，按“实际代价＋势能差=分摊代价”算。




# 一、真题（转写）

## 伸展树分摊时间复杂度（4 道题）

1. 理想随机的伸展树插入操作的分摊时间复杂度为 $O(\log n)$。（ ） （2018）
	对
2. 如果访问的序列不具备局部性，伸展树查找不能保证分摊 $O(\log n)$ 的时间。（ ） （2019, 2023, 2025）
    错

## 伸展树势能和高度变化问题（4 道题）

1. 伸展树总体势能不可能超过 $O(n\log n)$。（ ） （2022）
    对
2. 伸展树为单链时，势能达最小。（ ） （2024）
    错
3. 伸展树势能定义为 $\Phi(S)=\log\big(\prod_{v\in S}\mathrm{size}(v)\big)$，对于根结点为 $1$、共 $2025$ 个节点的**右侧单链**形式的伸展树，查找 $2025$，查找之前的势能为 $P$，查找之后的势能为 $Q$，则 $P-Q=$ ______（写出表达式即可）。（2025）
    势能差 P−Q的计算（并修正公式小笔误）


4. 一棵伸展树的某节点经访问后，节点被转换到根部，树的高度不一定降低。（ ） （2022）
    

---

# 二、我编的题

## 伸展树分摊时间复杂度与局部性（4 道）

1. 从任意初始形态出发，按键值顺序依次访问 $1,2,\dots,n$，伸展树的总访问代价为 $O(n)$。（ ） （2021）
    
2. 工作集性质：若反复只在 $k$ 个键上访问（$k\ll n$），则连续 $m$ 次查找的总成本为 $O(m\log k+n\log n)$。（ ） （2020）
    
3. 对完全随机且不重复的访问序列，伸展树查找的**分摊**复杂度阶与红黑树的**最坏**复杂度阶相同，均为 $O(\log n)$。（ ） （2022）
    
4. 若题目未明确“单层/双层”，默认采用双层伸展并给出分摊 $O(\log n)$ 的结论。（ ） （2019）
    

## 伸展步骤与形态变化（4 道）

1. 在“之字形”（父子位于祖父两侧）情况下，双层伸展一轮的两次旋转等价于**先旋父再旋祖父**的两次单旋，局部结果与连续两次单层伸展一致。（ ） （2023）
    
2. 在“一字形”（父子与祖父同侧）情况下，双层伸展的旋转顺序为**先旋祖父再旋父**；若改为先旋父再旋祖父，局部结果不同且性能变差。（ ） （2024）
    
3. 若当前访问结点 $v$ 的父 $p$ 已是根，则仅需一次单旋（Zig/Zag）即可把 $v$ 提至根。（ ） （2018）
    
4. Top-Down splay 实现不需要维护父指针，沿查找路径一边小旋一边用两棵临时树重联，最后拼回。（ ） （2020）
    

## 势能与访问引理（4 道）

1. 设等权势能 $\Phi(T)=\sum\limits_{v}\log s(v)$，其中 $s(v)$ 为以 $v$ 为根的子树规模。对于**右侧单链**的 $n$ 个结点，$\Phi(T)=\log(n!)$ 的数量级为 $\Theta(n\log n)$。（ ） （2024）
    
2. 在同一定义下，**完全二叉树**的势能数量级为 $\Theta(n\log n)$。（ ） （2021）
    
3. 访问引理（加权版）给出把 $x$ 伸展到根的分摊代价：$\ \tilde O\le 3\big(\log S-\log w(x)\big)+O(1)$，其中 $S=\sum w$。当 $w\equiv 1$ 时得到分摊 $O(\log n)$。（ ） （2022）
    
4. 设一棵右侧单链、结点键为 $1,2,\dots,n$，按等权势能定义。先查找 $n-1$ 再查找 $n$，两次操作的势能变化总量为 $(P_0-P_1)+(P_1-P_2)=$ ______（用对数与乘积形式写出表达式即可）。（2025）
    

## 操作与复杂度填空（4 道）

1. 连续 $m$ 次查找（$m\to\infty$），若访问仅限于固定的 $k$ 个键（$k\ll n$），则**分摊**复杂度为 $O(\ \underline{\quad}\ )$。（2023）
    
2. 从任意初始树出发，按升序依次访问 $n$ 个不同键的总复杂度为 $O(\ \underline{\quad}\ )$。（2020）
    
3. 对右侧单链的 $n$ 个结点，查找最大键 $n$ 一次后将其伸展到根，若查找前势能为 $P$、查找后为 $Q$，则 $P-Q=\ \underline{\quad}$（写出表达式即可）。（2025）
    
4. 若访问序列为周期性的 $1,2,\dots,n$ 循环且初始为单链，采用**单层**伸展时每一周期累计代价为 $O(\ \underline{\quad}\ )$，分摊为 $O(\ \underline{\quad}\ )$。（2022）
    