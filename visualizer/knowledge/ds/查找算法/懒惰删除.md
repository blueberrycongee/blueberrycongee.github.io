# 懒惰删除是啥、为啥要用

- **场景**：开放定址（线性/平方/双散列等）里，**直接把被删桶设为空会“断链”**，导致后续查找提前停止、出现假阴性。  
    例：表长 7，依次插入 `1→槽1`、`8→冲突后到槽2`、`2→再冲突到槽3`。若把 `8` 真的删空，查找 `2` 会在槽2见到“空”而误判不存在。
    
- **做法**：删除时**不清空**，只给桶打一个 **“已删除”标记**（lazy-deleted）。
    

# 带删除标记的桶在不同操作中的“角色”

- **查找（Search）**：把“已删除”桶视作**非空但不匹配**——继续试探，**保证试探链不断**，不会因删除而提前停。
    
- **插入（Insert）**：把“已删除”桶视作**可用位置**，可以在此**直接放入新键**，从而不影响插入进程。
    

# 关键实现与口径

- **插入时要不要清掉标记？**    **要！**
    
    - **教材老说法**：插入时“无需复位”删除标记。
        
    - **PPT/最新代码做法（正确且更合理）**：**插入时必须清除**该桶的“已删除”标记。文中明确指出教材做法不合理，已被修正。
        
- **装填因子（负载因子）的计算口径**：
    
    - 不能只数真实元素个数 `n`；**还要把带“已删除”标记的桶数也算进去**。
        
    - 文中给出的触发阈值示例：当
        
        $\frac{n + \text{deleted\_count}}{m} > 0.5$
        
        就触发重散列（rehash）。
        

# 与重散列（rehashing）的关系与注意

- **触发**：如上，负载因子按“**真实元素 + 删除标记**”计算，**超过 50% 就重散列**（文中的具体阈值示例）。
    
- **方式**：**重散列是“逐个重新插入”，不是按内存复制**。这是和向量扩容的“拷贝”不同的，必须重算位置并再插入一次。
    
- **为什么要把删除标记算进负载因子**：标记多了会**拖长试探链**、性能下降；计入后能**更早触发**重散列，恢复性能。
    

# 示例里的行为（巩固理解）

- 依次插入 `1、8、2`（如上形成试探链），**删除 `8`** 时只打标记；
    
    - **再查找 `2`**：遇到带标记的槽视为非空不中，**继续探测**到槽3找到 `2`；
        
    - **再插入 `9`**：可**复用**带标记的槽（并**清除标记**）。
        

# 与考试/实现细节相关的提醒

- 本讲义（PPT/最新代码）和部分书本表述**不一致**：以**最新PPT为准**（插入时清标记、负载因子计入标记、据此判断重散列时机）。
    
- 文中还提到查找/插入的判定函数逻辑（“是否命中/是否空桶”）正是依据上述**对标记桶的不同视角**来实现的。
    

# 小结（一句话版）

> 开放定址下删除不能清空，只能“打标”；查找把标记桶当**非空不中**继续探测，插入把它当**可用位**并**清标记**；**负载因子按“元素+标记”**计，超过阈值就**重散列（逐个重插）**。以上以**PPT/最新代码口径为准**。