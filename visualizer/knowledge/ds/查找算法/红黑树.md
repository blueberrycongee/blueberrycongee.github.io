# 红黑树 (Red-Black Tree) - C++实现

## 1. 基本概念

红黑树是一种弱平衡的二叉搜索树，由Rudolf Bayer在1972年发明。

​**核心思想**​：通过节点着色和旋转规则，保证树的平衡性，同时降低维护成本。

## 2. 红黑树的五条性质

1. 节点颜色：每个节点是红色或黑色
    
2. 根节点：根节点是黑色
    
3. 叶节点：所有NIL节点（空叶子）是黑色
    
4. 红色约束：红色节点的子节点必须是黑色（不能有连续的红节点）
    
5. 黑高相同：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
    

## 3. 节点结构定义

```
enum Color { RED, BLACK };

struct RBNode {
    int key;
    Color color;
    RBNode* left;
    RBNode* right;
    RBNode* parent;
    
    RBNode(int k, Color c = RED) 
        : key(k), color(c), left(nullptr), right(nullptr), parent(nullptr) {}
};
```

## 4. 重要概念

### 黑高（Black Height）

从节点到叶节点的路径上黑色节点的数量（不含该节点自身）

### 高度上界

包含n个节点的红黑树高度：​**h ≤ 2log₂(n+1)​**​

## 5. 操作复杂度

|操作|时间复杂度|说明|
|---|---|---|
|查找|O(log n)|同BST|
|插入|O(log n)|需要调整|
|删除|O(log n)|需要调整|

## 6. 拓扑结构变化量：O(1)

这是红黑树相比AVL的重要优势！

### 插入操作

- 最多3次旋转
    
- 拓扑结构变化：O(1)
    

### 删除操作

- 最多3次旋转
    
- 拓扑结构变化：O(1)
    

## 7. 旋转操作

### 7.1 左旋

```
void leftRotate(RBNode*& root, RBNode* x) {
    RBNode* y = x->right;
    x->right = y->left;
    
    if (y->left != nullptr) {
        y->left->parent = x;
    }
    
    y->parent = x->parent;
    
    if (x->parent == nullptr) {
        root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    
    y->left = x;
    x->parent = y;
}
```

### 7.2 右旋

```
void rightRotate(RBNode*& root, RBNode* y) {
    RBNode* x = y->left;
    y->left = x->right;
    
    if (x->right != nullptr) {
        x->right->parent = y;
    }
    
    x->parent = y->parent;
    
    if (y->parent == nullptr) {
        root = x;
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    
    x->right = y;
    y->parent = x;
}
```

## 8. 插入操作

### 8.1 基本插入

```
RBNode* insert(RBNode*& root, int key) {
    RBNode* node = new RBNode(key);
    
    // 标准BST插入
    RBNode* y = nullptr;
    RBNode* x = root;
    
    while (x != nullptr) {
        y = x;
        if (node->key < x->key) {
            x = x->left;
        } else {
            x = x->right;
        }
    }
    
    node->parent = y;
    if (y == nullptr) {
        root = node;
    } else if (node->key < y->key) {
        y->left = node;
    } else {
        y->right = node;
    }
    
    // 修复红黑树性质
    insertFixup(root, node);
    return root;
}
```

### 8.2 插入修复

```
void insertFixup(RBNode*& root, RBNode* node) {
    while (node->parent != nullptr && node->parent->color == RED) {
        if (node->parent == node->parent->parent->left) {
            RBNode* uncle = node->parent->parent->right;
            
            // 情况1：叔叔是红色
            if (uncle != nullptr && uncle->color == RED) {
                node->parent->color = BLACK;
                uncle->color = BLACK;
                node->parent->parent->color = RED;
                node = node->parent->parent;
            } else {
                // 情况2：节点是右孩子
                if (node == node->parent->right) {
                    node = node->parent;
                    leftRotate(root, node);
                }
                
                // 情况3：节点是左孩子
                node->parent->color = BLACK;
                node->parent->parent->color = RED;
                rightRotate(root, node->parent->parent);
            }
        } else {
            // 镜像情况
            RBNode* uncle = node->parent->parent->left;
            
            if (uncle != nullptr && uncle->color == RED) {
                node->parent->color = BLACK;
                uncle->color = BLACK;
                node->parent->parent->color = RED;
                node = node->parent->parent;
            } else {
                if (node == node->parent->left) {
                    node = node->parent;
                    rightRotate(root, node);
                }
                
                node->parent->color = BLACK;
                node->parent->parent->color = RED;
                leftRotate(root, node->parent->parent);
            }
        }
    }
    
    root->color = BLACK;
}
```

## 9. 删除操作

### 9.1 基本删除

```
RBNode* deleteNode(RBNode*& root, int key) {
    RBNode* z = search(root, key);
    if (z == nullptr) return root;
    
    RBNode* y = z;
    RBNode* x = nullptr;
    Color yOriginalColor = y->color;
    
    if (z->left == nullptr) {
        x = z->right;
        transplant(root, z, z->right);
    } else if (z->right == nullptr) {
        x = z->left;
        transplant(root, z, z->left);
    } else {
        y = minimum(z->right);
        yOriginalColor = y->color;
        x = y->right;
        
        if (y->parent == z) {
            if (x != nullptr) x->parent = y;
        } else {
            transplant(root, y, y->right);
            y->right = z->right;
            y->right->parent = y;
        }
        
        transplant(root, z, y);
        y->left = z->left;
        y->left->parent = y;
        y->color = z->color;
    }
    
    if (yOriginalColor == BLACK) {
        deleteFixup(root, x);
    }
    
    delete z;
    return root;
}
```

### 9.2 辅助函数

```
// 节点替换
void transplant(RBNode*& root, RBNode* u, RBNode* v) {
    if (u->parent == nullptr) {
        root = v;
    } else if (u == u->parent->left) {
        u->parent->left = v;
    } else {
        u->parent->right = v;
    }
    
    if (v != nullptr) {
        v->parent = u->parent;
    }
}

// 查找最小节点
RBNode* minimum(RBNode* node) {
    while (node->left != nullptr) {
        node = node->left;
    }
    return node;
}

// 查找节点
RBNode* search(RBNode* root, int key) {
    while (root != nullptr && key != root->key) {
        if (key < root->key) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return root;
}
```

## 10. 查找操作

```
RBNode* search(RBNode* root, int key) {
    while (root != nullptr && key != root->key) {
        if (key < root->key) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return root;
}
```

## 11. 红黑树 vs AVL树

|特性|红黑树|AVL树|
|---|---|---|
|平衡性|弱平衡|严格平衡|
|高度|最多2log₂(n+1)|最多1.44log₂(n)|
|查找效率|稍慢|最快|
|插入删除|快|慢|
|旋转次数|最多3次|插入1次，删除O(log n)|
|适用场景|插入删除频繁|查找频繁|

## 12. 实际应用

1. C++ STL：`std::map`, `std::set`
    
2. Java：`TreeMap`, `TreeSet`
    
3. Linux内核：进程调度，虚拟内存管理
    
4. 数据库：MySQL，Nginx
    

## 13. 为什么这么流行？

1. 性能稳定：O(log n)保证
    
2. 维护成本低：最多3次旋转
    
3. 实现成熟：广泛验证
    
4. 平衡折衷：平衡性和维护成本的最佳权衡
    

## 14. 相关主题

- 基于比较的算法（Comparison-Based Algorithm）
    
- 二叉搜索树（BST） - 基础结构
    
- AVL树 - 严格平衡方案
    
- 伸展树 - 自适应方案
    
- B树 - 多路平衡树
    

## 15. 常见面试题

1. 红黑树的性质
    
2. 红黑树vs AVL树如何选择
    
3. 红黑树的插入过程
    
4. 为什么STL使用红黑树而不是AVL树
    
5. 红黑树与2-3-4树的关系
    

## 16. 深入思考

### 为什么新插入节点是红色？

- 红色不影响黑高
    
- 只需要处理"连续红色"问题
    
- 如果是黑色，需要调整所有路径的黑高
    

### 为什么高度是2log₂(n+1)？

- 最短路径：全黑，长度为黑高bh
    
- 最长路径：黑红交替，长度为2bh
    
- n ≥ 2^bh - 1，得 h ≤ 2log₂(n+1)



