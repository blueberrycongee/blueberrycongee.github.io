# 多叉堆 (d-ary Heap)

## 一、核心目标

多叉堆的核心目标是**优化优先级队列在特定场景下的综合性能**，特别是作为经典 **PFS (Priority-First Search)** 算法（如 Dijkstra 或 Prim）的底层支持结构。

传统的**二叉堆**在**稀疏图** ($\mathcal{O}(E \log N)$) 中表现良好，但在**稠密图**中（$E \approx N^2$），其效率反而**低于**不使用堆的 $\mathcal{O}(N^2)$ 实现（此时二叉堆复杂度为 $\mathcal{O}(E \log N) \approx \mathcal{O}(N^2 \log N)$，效率更差）。

多叉堆通过**动态调整“叉数” $d$**，解决了这个问题，实现了**自适应优化**：

1.  **对于稠密图**：通过增大 $d$（使其接近 $\mathcal{O}(N)$ 级别），将 `decrease_key` 操作的成本（上滤）降低到 $\mathcal{O}(\log_d N) \approx \mathcal{O}(1)$，使 PFS 算法总复杂度逼近 $\mathcal{O}(N^2)$，实现极大优化。
2.  **对于稀疏图**：通过减小 $d$（使其接近 $\mathcal{O}(1)$ 级别，如 $d=2$ 或 $d=3$），保持 PFS 算法总复杂度为 $\mathcal{O}(E \log N)$，维持高效。

**简而言之：多叉堆是一种更“全能”的堆，它通过调整叉数 $d$ 来平衡“堆高度”和“单层比较次数”，以实现在稀疏图和稠密图上均接近最优的性能。**

## 二、核心机制与性能分析

### 1. 结构与实现
* **结构**：一个节点最多有 $d$ 个孩子。
* **存储**：可以像二叉堆一样，完全基于**向量 (Vector)** 实现。
* **父子关系（1-based indexing）**：
    * 节点 $k$ 的父节点：$\lfloor (k-1)/d \rfloor + 1$ (※ 讲师口误 $k-k-1 \div d$)
    * 节点 $k$ 的第 $i$ 个孩子 ($1 \le i \le d$)：$k \times d + i$ (※ 讲师口述为 $k \times d + I$)
* **缺点**：当 $d \ne 2$ 时，无法使用高效的**移位运算**来加速父子节点的查找。

### 2. 操作复杂度分析
* **堆高度**：$\mathcal{O}(\log_d N)$
* **建堆 (BuildHeap)**：时间复杂度仍为 $\mathcal{O}(N)$，与二叉堆的 Floyd 算法一致。

#### a. `insert` / `decrease_key` (上滤)
* **机制**：上滤操作只与**父节点**比较。
* **成本**：$\mathcal{O}(\log_d N)$。
* **课程示例**：(假设小根堆) 插入 7，只需与父节点 5 比较，7 > 5，插入完成。无需与兄弟 16, 17 比较。
* **接口辨析 (※课程提及)**：
    * 课程中 `increase` 接口（提高优先级）在实现小根堆时，对应的是 `decrease_key`（降低优先级数）。
    * 这两个接口作用和实现方式一致，不矛盾。

#### b. `delete_max` / `delete_min` (下滤)
* **机制**：下滤过程中，父节点需要与其**所有 $d$ 个孩子节点**比较（共 $d+1$ 个节点参与比较），找出最大/最小者进行交换。
    * 二叉堆 ($d=2$)：3个节点比较 2 次。
    * 三叉堆 ($d=3$)：4个节点参与比较。
    * 五叉堆 ($d=5$)：6个节点参与比较。
* **成本**：$\mathcal{O}(d \cdot \log_d N)$。（$d$ 次比较 $\times$ $\log_d N$ 层）

### 3. 关键结论：$d$ 的选择 (核心考点)

> [!NOTE] 核心考点：d-ary 堆的删除成本
> **问题**：是否 $d$ 越大，`delete_max` 成本就一定越高？
> **答案**：**不是。** 这是一个**比较次数** ($d$ 增加) 和**堆高度** ($\log_d N$ 减少) 之间的权衡。

* **成本正比于**：$d \times \log_d N = d \times \frac{\ln N}{\ln d} \propto \frac{d}{\ln d}$。
* **目标**：寻找 $f(d) = \frac{d}{\ln d}$ 的最小值。
* **数学分析 (课程演示：比较 $d=2$ 和 $d=3$)**：
    * 比较 $\frac{2}{\ln 2}$ 和 $\frac{3}{\ln 3}$。
    * 做减法：$\frac{2}{\ln 2} - \frac{3}{\ln 3} = \frac{2 \ln 3 - 3 \ln 2}{\ln 2 \cdot \ln 3}$
    * 分子：$2 \ln 3 - 3 \ln 2 = \ln(3^2) - \ln(2^3) = \ln 9 - \ln 8$
    * 因为 $\ln 9 > \ln 8$，所以分子**大于 0**。
    * **结论**：$\frac{2}{\ln 2} > \frac{3}{\ln 3}$。
* **d-ary 堆成本结论**：
    * **$d=3$ (三叉堆)**：成本**最低**。
    * **$d=4$**：成本与 $d=2$ **相同** (因为 $\frac{4}{\ln 4} = \frac{4}{2 \ln 2} = \frac{2}{\ln 2}$)。
    * **$d>4$**：成本开始**增加**。

> [!TIP] 考点提示 (判断题)
> **“多叉堆的删除成本一定高于二叉堆。”**
> **这是错误的**。$d=3$ 时成本更低，因为虽然比较次数多了，但堆的高度矮了，且抵消效果更强。 (※ 课程习题 Q3)

#### b. 针对 PFS 算法 (Dijkstra / Prim)
* PFS 总成本 = $N$ 次 `delete_min` + $E$ 次 `decrease_key`。
* 总成本 $\approx \mathcal{O}(N \cdot (d \log_d N) + E \cdot (\log_d N))$。
* **最优结论 (必须记住)**：当 $d$ 选取为 **$d \approx \frac{E}{N} + 2$** 时，PFS 算法的**总体性能达到最优**。
    * (※ 讲师 justifying `+2`：至少是二叉堆，这个公式易于记忆)。
    * 这个 $d$ 值是自适应的，它根据图的稠密程度 ($E/N$) 自动调整。

> [!IMPORTANT] 2019 年考题 (简答题)
> **简答题 (2019年)**：为什么使用多叉堆（替换完全二叉堆）来优化 PFS（如 Dijkstra）？ (※ 课程习题 Q4)
> **答案**：即上述分析。二叉堆在稠密图上效率低 ($\mathcal{O}(N^2 \log N)$)；多叉堆通过选取最优 $d \approx E/N + 2$，使算法具有自适应性，在稀疏图上保持 $\mathcal{O}(E \log N)$，在稠密图上逼近 $\mathcal{O}(N^2)$，实现整体最优。