
---
# 散列表：冲突解决方法之开放散列

## 1. 冲突解决策略概述

在散列表中，当两个或多个不同的键（Key）通过散列函数计算出相同的散列地址（Hash Address）时，就会发生**冲突 (Collision)**。解决冲突是散列表设计的核心问题之一，主要分为两大类策略：

- **开放散列 (Open Hashing)**: 将发生冲突的词条（Entry）存储在散列表主体**之外**的辅助空间中。本次笔记主要讨论此方法。
    
- **封闭散列 (Closed Hashing / Probing)**: 或称**闭散列**，当发生冲突时，在散列表主体**内部**寻找下一个可用的空桶来存储词条。
    

> **※ 考试重点提示**: 讲师提及 **2019年考研简答题** 曾考过 **封闭散列与开放散列的对比**，要求阐述各自的优点并举例说明。

## 2. 开放散列 (Open Hashing) 的具体方法

开放散列的核心思想是将冲突的同义词（Synonyms）组织在散列表主体桶之外。主要有以下三种方法：

### 2.1 多槽位法 (Multiple Slots / Bucketing)

- **核心原理**: 将散列表中的每一个桶 (Bucket) 单元进一步细分为若干个**槽位 (Slot)**，用于存放发生冲突的词条。这在逻辑上可以将一维的散列表看作一个二维数组。
    
- **查找过程**:
    
    1. 通过散列函数计算得到桶的索引，例如 `15`。
        
    2. 顺序检查该桶内的各个槽位（如 `A[15][0]`, `A[15][1]`, ...），逐一比对槽位中存储的**关键码 (Key)** 是否与待查找的关键码匹配。
        
    3. 如果匹配成功，则返回对应信息。如果遍历完所有槽位仍未找到，则查找失败。
        
- **示例**:
    
    - 假设有两个电话号码：张三的 `12345670` 和王五的 `76543210`。
        
    - 经过散列函数计算后，二者都映射到地址 `15`。
        
    - 此时，可以将地址为 `15` 的桶设计为拥有多个槽位。例如，在第一个槽位 `A[15][0]` 存储王五的完整电话号码和信息，在第二个槽位 `A[15][1]` 存储张三的完整电话号码和信息。
        
- **优点**:
    
    - **效率**: 只要预留的槽位数目不多，查找、插入操作的时间效率仍然可以维持在接近 ![](data:,) 的水平。
        
- **缺点**:
    
    - **空间浪费严重**: 如果槽位设置过多，而大部分桶中并未发生冲突或冲突次数很少，那么这些预留的空槽位会造成大量的空间浪费。例如，桶 `15` 可能需要很多槽位，而桶 `12`, `13`, `18`, `19` 可能完全是空的，但它们也被分配了同样多的槽位空间。
        
    - **可能仍会溢出**: 在极端情况下，即使预设了多个槽位，冲突的词条数也可能超过槽位数，导致无法存入。动态增加槽位会使设计变得非常麻烦。
        

### 2.2 独立链法 (Separate Chaining)

- **核心原理**: 为散列表中的每个桶配置一个**列表（通常是链表）**。所有散列到该桶的词条（无论是否冲突）都以节点的形式添加到这个链表中。
    
- **示例**:
    
    - 假设 `12345670`, `76543210` 等多个电话号码都散列到地址 `15`。
        
    - 那么在散列表的 `15` 号桶位置，会存储一个指向链表头节点的指针。
        
    - 这个链表依次包含 `12345670`, `76543210` 等词条节点。查找时，只需遍历这个短链表即可。
        
- **优点**:
    
    - **空间利用率高**: 无需为每个桶预留固定的槽位，按需分配节点，避免了多槽位法中大量的预留空间浪费。
        
    - **无溢出问题**: 理论上可以处理任意多次的冲突，只需不断向链表中添加新节点即可。
        
    - **删除操作简单**: 删除操作仅需在链表中删除一个节点，实现简单统一。
        
- **缺点**:
    
    - **指针占用空间**: 链表中的每个节点都需要额外的指针域来维护链式关系，这会带来一定的空间开销。
        
    - **动态分配开销**: 节点的动态分配和回收（如 `new`/`delete` 或 `malloc`/`free`）需要消耗额外的时间。
        
    - **※ 缓存不友好 (Poor Cache Locality)**: 这是**所有开放散列方法**相较于封闭散列方法的一个重要且普遍的缺点，在独立链法中尤为明显。
        
        - **原理**: 链表的节点在内存中通常是**非连续存储**的。当CPU访问一个节点后，下一个节点可能位于内存中一个完全不相关的、很远的位置。
            
        - **与封闭散列（线性试探）对比**: 线性试探法中，冲突的词条存储在相邻的物理位置（如 `15` 号冲突存 `16` 号，`16` 号冲突存 `17` 号）。当CPU访问 `15` 号桶时，由于**局部性原理 (Locality of Reference)**，计算机会将 `15` 号桶及其附近（包括 `16`, `17` 号）的一整块内存数据加载到高速缓存 (Cache) 中。后续访问 `16` 或 `17` 号桶时，可以直接从 Cache 中快速命中，无需访问慢速的主存。
            
        - **结论**: 独立链法由于其节点的离散分布，导致 **Cache 命中率低**，系统缓存很难生效，从而影响实际的查询性能。
            

### 2.3 公共溢出区法 (Public Overflow Area)

- **※ 重要归类说明**: 讲师明确指出，PPT课件中将此方法错误地归类于“封闭散列”是**串行错误**。从底层逻辑看，该方法为冲突词条**单独开辟了一块外部存储区域**，不占用散列表主体内部的其他桶，因此它**明确属于开放散列**。封闭散列 (Closed Hashing) 的定义是所有冲突都在散列表的**物理空间内部**解决。
    
- **核心原理**: 设立一个独立的、连续的存储区域（通常是一个数组），称为**公共溢出区**。所有在散列表中发生冲突的词条，都按顺序存放到这个溢出区中。
    
- **优点**:
    
    - **实现简单**: 结构和算法都非常简单直观。
        
- **缺点**:
    
    - **查找效率低**: 发生冲突后，最坏情况下可能需要线性遍历整个溢出区来查找目标词条，查找时间与溢出区的规模成正比，性能下降快。
        
- **※ 实现方式的差异 (PPT vs. 教材/常规实现)**:
    
    - **教材/常规实现 (无指针)**: 这是主流和考试（如408）中常见的设计。公共溢出区就是一个简单的数组。发生冲突时，将词条存入，查找时从头到尾线性扫描溢出区。如果溢出区内混杂了来自不同桶的冲突词条，也需要一并进行比对。
        
    - **PPT展示的实现 (带指针)**: PPT中展示了一种更复杂的设计。虽然溢出区是物理连续的，但在逻辑上，属于同一个桶的冲突词条通过“指针”（可以用数组下标模拟）形成一个链表。
        
        - **示例**: 桶 `15` 冲突的词条在溢出区中可能存储在索引 `0, 2, 5` 的位置，它们通过指针 `0 -> 2 -> 5` 链接起来。而桶 `12` 冲突的词条可能在 `1, 3, 4` 位置，形成另一条逻辑链。
            
        - **优点**: 查找时可以沿着特定逻辑链进行，减少了不必要的关键码比对次数。
            
        - **缺点**: 大大增加了设计的复杂性，尤其是在插入和删除词条时，需要维护这些指针关系。