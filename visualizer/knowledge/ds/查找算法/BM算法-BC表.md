**3. 仅用坏字符表的BM算法性能分析**​

- ​**最好情况时间复杂度**​：`O(n/m)`。
    
    - ​**发生场景**​：每次比较，文本串中的坏字符都**不在**模式串中（情况二），模式串可以大幅移动。
        
    - ​**例子**​：文本串为"0000000001"，模式串为"111"。每次比较第一个字符就发现不匹配，移动距离大。
        
    
- ​**最坏情况时间复杂度**​：`O(n * m)`。
    
    - ​**发生场景**​：每次比较，前面所有字符都匹配，直到最后一个字符才失败（情况三），导致每次只能移动1位。
        
    - ​**例子**​：文本串为"0000000000"，模式串为"0001"。每次都比对到模式串开头才发现不匹配。
        
    

​**4. 坏字符表（BC表）的构造**​

- ​**目的**​：记录每个字符在模式串中**最后一次（最右边）出现的位置**。
    
- ​**算法**​：“画家算法”。
    
    - 初始化一个数组（大小由字符集决定，如ASCII码为256），所有值设为-1（表示该字符未出现）。
        
    - 遍历模式串，对于每个位置 `i`上的字符 `c`，直接执行 `BC[c] = i`。
        
    - ​**原理**​：后出现的索引会覆盖先出现的索引，遍历完成后，`BC[c]`中存储的就是字符 `c`在模式串中最右的位置。
        
    
- ​**注意点**​：PPT示例中直接用字母顺序（A=0, B=1...）作为下标是不准确的，实际应使用字符的ASCII码（如‘A’=65）。


二维BC表

将二维BC表视为对一维BC表的一种“精细化”升级。一维BC表只回答一个问题：​**​“字符X在整个模式串P中最右出现在哪个位置？”​**​ 而二维BC表则回答一个更具体的问题：​**​“在模式串P的第j个位置之前（即左侧），字符X最右出现在哪个位置？”​**

**二维BC表的优势:** 二维BC表的结构是 `BC[i][x]`,表示:

- 在模式串P的位置i的**左侧**
- 与字符x最接近的那个x的位置

模式串  P: A  B  C  A  B  C
位置索引:  0  1  2  3   4   5


在二维BC表中，**如果某个字符在字符集中，但不在模式串P中出现**，那么：

- 该字符对应的**所有位置的值都是 -1**