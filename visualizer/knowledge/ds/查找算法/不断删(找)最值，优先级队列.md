[[完全二叉堆]]

[[数据结构/查找算法/多叉堆]]

[[数据结构/查找算法/左式堆]]

[[数据结构/查找算法/锦标赛树]]
## 一、核心定义与目标

### 1. 什么是优先级队列？
优先级队列 (Priority Queue) 是一种抽象数据类型 (ADT)，它允许高效地存取元素，但存取规则基于“优先级”而非“插入顺序”。

* **对比普通队列 (Queue)**：普通队列遵循“先进先出”(FIFO)。
* **优先级队列 (PQ)**：遵循“**最高优先级优先出**”(Highest-Priority-First-Out, HPFO)。

### 2. 核心特征
* **元素**：队列中的每个元素都关联一个**优先级**（或称“键值”，Key）。
* **操作**：`pop` 操作总是移除并返回当前队列中优先级最高的元素。
* **应用场景**：
    * **医院急诊室**：按病情紧急程度服务。
    * **操作系统**：按任务优先级调度 CPU。
    * **图算法**：如 Dijkstra (最短路径)、Prim (最小生成树)。
    * **事件驱动模拟**：按事件发生时间顺序处理。
    * **数据压缩**：赫夫曼编码 (Huffman Coding)。

## 二、核心操作 (API)

优先级队列通常支持以下操作（以“数值越小，优先级越高”的小根堆为例）：

1.  **`insert(element, priority)` / `push(element)`**
    * **功能**：向队列中**插入**一个新元素。
    * **复杂度**：取决于实现，通常为 $\mathcal{O}(\log N)$。

2.  **`find_min()` / `top()`**
    * **功能**：**查看**（不移除）当前优先级最高（最小）的元素。
    * **复杂度**：通常为 $\mathcal{O}(1)$。

3.  **`delete_min()` / `pop()`**
    * **功能**：**移除**并**返回**当前优先级最高（最小）的元素。
    * **复杂度**：通常为 $\mathcal{O}(\log N)$。

4.  **`decrease_key(element, new_priority)`**
    * **功能**：（可选）将队列中某个元素 $element$ 的优先级**提升**（即将其键值降低为 $new\_priority$，新值必须比旧值小）。
    * **复杂度**：取决于实现，$\mathcal{O}(\log N)$ 或 $\mathcal{O}(1)$ (斐波那契堆)。

5.  **`merge(pq1, pq2)`**
    * **功能**：（可选）将两个优先级队列合并为一个。

## 三、常见的实现方式及其对比

优先级队列是一种抽象类型，可以用多种具体的数据结构来实现，不同的实现方式在各项操作的效率上各有取舍。

| 实现方式 | `insert` | `delete_min` | `find_min` | `decrease_key` | `merge` |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **无序数组/链表** | $\mathcal{O}(1)$ | $\mathcal{O}(N)$ | $\mathcal{O}(N)$ | $\mathcal{O}(1)$ (需先找到) | $\mathcal{O}(N+M)$ |
| **有序数组/链表** | $\mathcal{O}(N)$ | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ | $\mathcal{O}(N)$ (需移动) | $\mathcal{O}(N+M)$ |
| **二叉堆 (Binary Heap)** | $\mathcal{O}(\log N)$ | $\mathcal{O}(\log N)$ | $\mathcal{O}(1)$ | $\mathcal{O}(\log N)$ | $\mathcal{O}(N+M)$ |
| **多叉堆 (d-ary Heap)** | $\mathcal{O}(\log_d N)$ | $\mathcal{O}(d \log_d N)$ | $\mathcal{O}(1)$ | $\mathcal{O}(\log_d N)$ | $\mathcal{O}(N+M)$ |
| **左偏堆 (Leftist Heap)** | $\mathcal{O}(\log N)$ | $\mathcal{O}(\log N)$ | $\mathcal{O}(1)$ | $\mathcal{O}(\log N)$ | **$\mathcal{O}(\log N)$** |
| **斐波那契堆 (Fibonacci Heap)**| $\mathcal{O}(1)$ | $\mathcal{O}(\log N)$ (摊销) | $\mathcal{O}(1)$ | **$\mathcal{O}(1)$** (摊销) | **$\mathcal{O}(1)$** |

---

## 四、最核心的实现：二叉堆 (Binary Heap)

在大多数应用中，“优先级队列”几乎等同于“**二叉堆**”，因为它的实现简单且性能均衡（所有操作均为 $\mathcal{O}(\log N)$ 或 $\mathcal{O}(1)$）。

### 1. 什么是二叉堆？
二叉堆是一种特殊的二叉树，满足以下两个性质：

1.  **结构性 (完全二叉树)**：
    * 它是一棵**完全二叉树** (Complete Binary Tree)。这意味着树的每一层都是满的，除了可能的最后一层，且最后一层的节点都**尽量靠左**排列。
    * 这个性质使得二叉堆可以被高效地存储在一个**数组（向量）**中，无需使用指针。

2.  **堆序性 (Heap-Order Property)**：
    * 父节点的优先级**总是**高于或等于其子节点的优先级。
    * **最大堆 (Max-Heap)**：父节点 $\ge$ 子节点。(`find_max` 为 $\mathcal{O}(1)$)
    * **最小堆 (Min-Heap)**：父节点 $\le$ 子节点。(`find_min` 为 $\mathcal{O}(1)$)

### 2. 数组实现 (关键)
如果根节点索引为 0：
* 节点 `i` 的父节点：`floor((i - 1) / 2)`
* 节点 `i` 的左孩子：`2 * i + 1`
* 节点 `i` 的右孩子：`2 * i + 2`
(※ 课程中也提到了 1-based indexing，关系会变为 `floor(i/2)`, `2*i`, `2*i+1`)

### 3. 核心操作的实现机制

#### a. `insert` (插入)
* **机制**：**上滤 (Percolate Up / Sift-Up)**
    1.  将新元素添加到数组的**末尾**（即完全二叉树的最后一个位置）。
    2.  **上滤**：不断将该元素与其**父节点**比较：
        * 如果新元素的优先级**高于**其父节点，则两者**交换**。
        * 重复此过程，直到新元素到达根节点，或其优先级不再高于父节点。
* **复杂度**：$\mathcal{O}(\log N)$ (树的高度)。

#### b. `delete_min` (删除最小/根)
* **机制**：**下滤 (Percolate Down / Sift-Down)**
    1.  **记录**根节点（即数组第一个元素），这是要返回的值。
    2.  将数组**最后一个**元素（即完全二叉树最右下角的叶子）移动到**根节点**位置（覆盖掉原来的根）。
    3.  **下滤**：不断将这个新根与其**子节点**（中优先级最高/最小的那个）比较：
        * 如果新根的优先级**低于**其子节点，则两者**交换**。
        * 重复此过程，直到该元素“下沉”到其正确位置（其优先级高于所有子节点），或它成为叶子节点。
* **复杂度**：$\mathcal{O}(\log N)$ (树的高度)。

#### c. `build_heap` (批量建堆)
* **目标**：给定一个无序数组，如何快速将其转换为一个堆？
* **错误方法**：逐个 `insert` $N$ 个元素。复杂度：$\mathcal{O}(N \log N)$。
* **正确方法 (Floyd 算法)**：
    1.  从**最后一个非叶子节点**开始（即索引 `floor(N/2) - 1`），**向前**遍历到根节点。
    2.  对遍历到的每个节点，执行一次**下滤 (Sift-Down)**。
* **复杂度**：$\mathcal{O}(N)$。这是一个非常重要的结论，效率远高于 $\mathcal{O}(N \log N)$。