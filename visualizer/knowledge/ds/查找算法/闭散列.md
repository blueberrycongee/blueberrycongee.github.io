# 散列表：冲突解决方法之封闭散列

## 3. 封闭散列 (Closed Hashing) / 开放定址法 (Open Addressing)

### 3.1 基本概念

- ​**核心思想**: 当发生冲突时，​**在散列表的内部**寻找下一个可用的空桶来存储词条，而不是开辟外部空间。因此，所有词条都存储在散列表主体数组中。
    
- ​**※ 同义词**: ​**封闭散列**​ (Closed Hashing) 与 ​**开放定址**​ (Open Addressing) 是同一概念的两种不同叫法。
    
    - "封闭"指的是所有操作都在散列表的物理空间内完成，是封闭的。
        
    - "开放定址"指的是冲突后，目标存储地址是开放的、不固定的，需要通过后续探测来确定。
        
    
- ​**探测序列 (Probe Sequence)​**: 当一个位置 `h`发生冲突后，会按照一个预定的规则依次检查一系列其他的桶 `h₀, h₁, h₂, ...`，这个序列就称为探测序列。不同的探测方法会产生不同的探测序列。
    
- ​**优点**:
    
    - ​**结构简洁**: 无需像独立链法那样使用指针，不涉及额外的动态空间分配。
        
    - ​**缓存友好**: 数据存储在连续的数组中，具有更好的缓存局部性 (Cache Locality)，CPU 缓存机制可以有效工作，实际运行效率通常更高。
        
    

### 3.2 线性试探法 (Linear Probing)

这是最简单的封闭散列方法。

- ​**核心原理**: 如果目标地址 `h`被占用，则依次探测 `(h+1) % m`, `(h+2) % m`, ...，直到找到一个空桶为止（其中 `m`为散列表长度）。
    
- ​**终止条件**: 只要散列表中还存在空桶（即装填因子 λ < 1），探测过程就一定能终止。
    
- ​**主要缺点：一次聚集/堆积 (Primary Clustering)​**​
    
    - ​**现象**: 散列表中连续被占用的桶会连接成片，形成"聚集区域"。
        
    - ​**成因**: 即使是不同义词（即它们的原始散列地址不同），只要其中一个词条的探测链经过了某个聚集区域，它就不得不存储在该区域的末尾，从而使这个聚集区域变得更长。这导致非同义词之间也可能彼此堆积。
        
    - ​**示例**: 设散列表长度 `m=7`。
        
        1. 插入 `1`：`hash(1) % 7 = 1`，存入 `table[1]`。
            
        2. 插入 `8`：`hash(8) % 7 = 1`，与 `1`冲突。向后探测，存入 `table[2]`。
            
        3. 插入 `2`：`hash(2) % 7 = 2`，此时 `table[2]`已被 `8`占用，再次冲突。向后探测，存入 `table[3]`。
            
        
        > 在此例中，`2`和 `8`并非同义词，但由于 `8`占据了 `2`的原始位置，导致 `2`也加入了这个由 `1`和 `8`形成的聚集块中。
        
    
- ​**性能分析**:
    
    - 性能严重依赖于**装填因子 (Load Factor)​**​ λ = n/m（`n`为元素个数，`m`为表长）。
        
    - 对于一次**不成功的查找**​（或**插入**操作），其期望探测次数至多为 1/(1-λ)²。
        
    - ​**※ 结论出处**: 该结论的详细证明见于**​《算法导论》(Introduction to Algorithms)​**​ (定理11.6)。
        
    
- ​**※ 知识点拓展 (讲师提及)​**:
    
    - ​**科研前沿**: 线性试探这种看似简单的结构，其深层理论至今仍是计算机科学研究的前沿。
        
    - ​**姚期智猜想**: 1985年，图灵奖得主姚期智院士曾对线性试探的期望探测次数提出一个猜想，该猜想在近40年后的2024年被国外一名本科生改进。这说明了基础理论研究的深度与魅力。
        
    - ​**​《算法导论》的重要性**: 讲师强调，近年（22、23、24年）的考研真题中多次出现《算法导论》中的定理和结论，特别是在散列这一章，建议考生拓展阅读。
        
    

#### 3.2.1 线性试探中的删除问题与懒惰删除

- ​**问题描述**: 不能简单地将被删除的元素置空。这样做会"切断"探测链，导致后续元素无法被查找到。
    
    - ​**示例**: 承上例，`{1 at table[1], 8 at table[2], 2 at table[3]}`。若此时删除 `8`并将 `table[2]`置空。当查找 `2`时，计算出地址为 `2`，发现该位置为空，系统会错误地报告 `2`不存在。
        
    
- ​**低效解决方案**: 删除一个元素后，将该位置之后所有在探测链上的元素重新进行一次插入。这种方法过于暴力，效率极低。
    
- ​**高效解决方案：懒惰删除 (Lazy Deletion)​**​
    
    - ​**核心思想**: 不真正删除物理数据，而是为被删除的桶设置一个特殊的**​"懒惰删除"标记 (DELETED)​**。
        
    - ​**标记桶的双重角色**:
        
        1. ​**对于查找 (Search) 操作**: 将该桶视作一个**不匹配的非空桶**。这意味着查找操作遇到此标记时，虽然知道当前元素不是目标，但探测链并未中断，需要继续向下探测。
            
        2. ​**对于插入 (Insert) 操作**: 将该桶视作一个**可用的空桶**。新元素可以插入到这个位置，从而复用空间。
            
        
    - ​**※ 版本差异与考点标准 (重要)​**​
        
        - ​**旧版教材**: 插入新元素到标记桶时，无需复位（清除）懒惰删除标记。
            
        - ​**最新代码/PPT/当前考试标准**: 插入新元素时，​**应清除懒惰删除标记**，使该桶恢复为正常的占用状态。讲师明确指出，根据真题选项分析，考试**应以此最新标准为准**。
            
        - ​**历史局限性**: 基于此，一些旧的习题（如习题解析9-18）是基于"不清除标记"的旧规则设计的，可能与当前标准不符。
            
        
    

#### 3.2.2 重散列 (Re-hashing)

- ​**触发时机**: 当装填因子过高时（例如，PPT代码中设置为大于50%），散列表性能会急剧下降，此时需要进行重散列。
    
    - ​**注意**: 在计算装填因子以判断是否需要重散列时，应将带有"懒惰删除"标记的桶也计算在内。即：λ = (有效词条数 + 懒惰删除标记数) / 表长。
        
    
- ​**核心原理**:
    
    1. 创建一个容量更大的新散列表（通常是原容量的两倍以上，并取一个素数作为新容量）。
        
    2. 遍历**旧表**中的所有**有效词条**。
        
    3. 将每一个词条通过**新的散列函数**​（因为模 `m`改变了）重新计算散列地址，并将其**插入**到**新表**中。
        
    
- ​**※ 关键点：重插而非复制**​
    
    - 重散列**绝不是**像动态数组扩容那样简单地将旧数据复制到新空间。
        
    - ​**原因**: 散列表的长度 `m`是散列函数的一部分（通常是取模运算）。当 `m`改变后，同一个键 `key`的散列值 `hash(key) % m'`几乎必然会改变。
        
    - ​**结论**: 必须对旧表中的每个元素执行一次完整的、基于新表长度的插入操作。
        
    

---

### 附：《算法导论》相关定理补充 (讲师提及)

> 以下为讲师在课程中补充的、源自《算法导论》的几个重要性能结论，其中有真题考点。

- ​**定理 11.6 (线性试探-不成功查找)​**: 在开放定址散列表中，对于一次不成功的查找，其期望探测次数至多为 1/(1-λ)。 (2024年真题考点)
    
- ​**定理 11.8 (线性试探-成功查找)​**: 在开放定址散列表中，一次成功查找的期望探测次数至多为 (1/λ) × ln(1/(1-λ))。
    
    - ​**分析**: 这个值远小于不成功查找的期望。例如，当表半满(λ=0.5)时，成功查找期望小于1.387次；当表快满(λ=0.9)时，也仅小于2.559次（而不成功查找则需要10次）。
        
    
- ​**定理 11.1 (独立链法-不成功查找)​**: 在使用链接法解决冲突的散列表中，一次不成功的查找平均需要探测的结点数为 λ。
    
- ​**定理 11.2 (独立链法-成功查找)​**: 在使用链接法解决冲突的散列表中，一次成功查找的平均时间为 1 + λ/2。 (2023年真题考点)
    
    - ​**※ 2023年真题细节**: 考题涉及该定理更精确的数学表达，其期望为 1 + λ/2。讲师提到，当年此题因计算结果不是整数，且直接套用 1 + λ/2 的错误做法得出的答案"过于完美"，可能导致大部分考生失分。这再次凸显了掌握《算法导论》精确结论的重要性。