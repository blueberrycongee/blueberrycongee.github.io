# BM算法GS表构造完整三步走方法

## 前置知识

### SS表定义

​**SS[i]​**​ = 从P[i]开始，与P[m-1]右对齐，从右往左连续匹配成功的字符个数

### GS表定义

​**GS[i]​**​ = 当在位置i发生失配时，模式串P应向右移动的距离

## 完整三步走流程

### 第一步：初始化

将所有 GS[i] 初始化为 m（模式串长度）

```
GS[0] = m
GS[1] = m
...
GS[m-1] = m
```

### 第二步：处理情况A（SS[j] = j+1）

​**条件**​：有前缀等于好后缀的后缀

​**处理步骤**​：

1. 查找所有满足 SS[j] = j+1 的位置j（跳过j=m-1）
    
2. 从右往左遍历这些j值（j从大到小）
    
3. 对每个j：
    
    - 计算移动距离：`distance = m - j - 1`
        
    - 更新范围：`i ∈ [0, m-j-2]`
        
    - 更新规则：
        
        ```
        for i from 0 to m-j-2:
            if GS[i] == m:  // 仅更新初始值
                GS[i] = m - j - 1
        ```
        
    - ​**关键**​：只更新那些仍为初始值m的位置，不覆盖已更新的值
        
    

### 第三步：处理情况B（SS[j] < j+1）

​**条件**​：中间存在与好后缀匹配的子串

​**处理步骤**​：

1. 按SS值分类所有满足 SS[j] < j+1 的位置
    
2. 对每个SS值，选择最右边（最大）的j
    
3. 对每个选中的j：
    
    - 更新位置：`pos = m - SS[j] - 1`
        
    - 移动距离：`distance = m - j - 1`
        
    - 更新规则：
        
        ```
        GS[m - SS[j] - 1] = m - j - 1  // 直接覆盖
        ```
        
    - ​**关键**​：直接覆盖任何值（包括已更新的值）
        
    

## 算法特点总结

- ​**情况A**​：前缀匹配好后缀，保守更新（不覆盖）
    
- ​**情况B**​：子串匹配好后缀，强制更新（直接覆盖）
    
- 优先级：情况B会覆盖情况A的更新结果