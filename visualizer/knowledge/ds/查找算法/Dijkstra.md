# Dijkstra（迪杰斯特拉）算法全面解析

## 1. 算法解决的问题

Dijkstra算法解决的是**单源最短路径问题**​(Single-Source Shortest Path, SSSP)：

- 在**边权非负**的加权图中
    
- 给定一个起点s
    
- 计算s到图中所有其他顶点的最短路径及其长度
    

典型应用场景：

- 地图导航（最短路线规划）
    
- 网络路由（如OSPF协议中的SPF计算）
    
- 任务调度和成本最小化问题
    

## 2. 核心思想与算法原理

### 贪心策略 + 松弛操作

算法维护两个核心数据结构：

1. ​**已确定最短距离的顶点集合S**​（初始为空）
    
2. ​**起点到各顶点的当前最优估计dist[]​**​
    

算法步骤如下：

1. 初始化：dist[s] = 0，其他顶点dist值为∞
    
2. 每次从**未确定的顶点**中选择**dist最小的顶点u**加入集合S（贪心选择）
    
3. 对u的所有邻边进行**松弛操作**​：
    
    - 对于u的每个邻居v，检查dist[v] > dist[u] + w(u,v)
        
    - 如果成立，则更新dist[v] = dist[u] + w(u,v)
        
    - 同时记录parent[v] = u（用于路径还原）
        
    
4. 重复上述过程直到所有顶点都被处理
    

### 关键性质

- ​**非负权边保证**​：由于所有边权非负，一旦顶点u被加入S，其最短距离就不会再被修改
    
- ​**最优子结构**​：最短路径的任何子路径也是最短路径
    

## 3. 适用范围与局限性

### 适用场景

- ✅ 边权**非负**的有向图或无向图
    
- ✅ 稀疏图或稠密图均可（实现方式不同）
    
- ✅ 单源到所有其他顶点的最短路径计算
    

### 不适用场景

- ❌ 图中存在**负权边**​（会导致贪心策略失效）
    
- ❌ 需要检测负权环（应使用Bellman-Ford算法）
    

### 替代方案

- ​**Bellman-Ford**​：可处理负权边，能检测负权环
    
- ​**Johnson算法**​：全源最短路径，适用于无负权环的图
    

## 4. 时间复杂度与空间复杂度

### 时间复杂度

取决于具体实现方式：

1. ​**优先队列（二叉堆）实现**​：O((V+E)logV) - 最常用
    
2. ​**斐波那契堆实现**​：O(E + VlogV) - 理论最优
    
3. ​**邻接矩阵+朴素实现**​：O(V²) - 适合稠密图
    

### 空间复杂度

O(V+E) - 用于存储图的邻接表和辅助数据结构

## 5. C++完整实现（含路径还原）

```cpp
#include <bits/stdc++.h>
using namespace std;

struct DijkstraResult {
    vector<long long> dist;    // 最短距离数组
    vector<int> parent;        // 前驱节点数组
};

const long long INF = (long long)4e18;

// Dijkstra算法实现
// 参数说明：
// n - 顶点数量
// adj - 邻接表，adj[u] = { {v, w}, ... }
// s - 起点
DijkstraResult dijkstra(int n, const vector<vector<pair<int,int>>>& adj, int s) {
    vector<long long> dist(n + 1, INF);    // 距离初始化为无穷大
    vector<int> parent(n + 1, -1);         // 前驱初始化为-1

    // 使用小根堆，存储{距离, 顶点}对
    using P = pair<long long, int>;
    priority_queue<P, vector<P>, greater<P>> pq;

    dist[s] = 0;
    pq.push({0, s});

    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        // 懒删除：如果当前距离不是最新值，跳过
        if (d != dist[u]) continue;

        // 遍历所有邻边
        for (auto [v, w] : adj[u]) {
            if (dist[v] > d + w) {
                dist[v] = d + w;           // 更新距离
                parent[v] = u;             // 更新前驱
                pq.push({dist[v], v});     // 将新距离加入堆
            }
        }
    }
    return {dist, parent};
}

// 还原从起点到终点t的路径
vector<int> get_path(int t, const vector<int>& parent) {
    vector<int> path;
    // 从终点回溯到起点
    for (int cur = t; cur != -1; cur = parent[cur]) {
        path.push_back(cur);
    }
    reverse(path.begin(), path.end());    // 反转得到正向路径
    return path;
}

int main() {
    int n = 6;    // 顶点数量
    vector<vector<pair<int,int>>> adj(n + 1);
    
    // 添加边的辅助函数
    auto add_edge = [&](int u, int v, int w) {
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});    // 无向图需要双向添加
    };

    // 构建图结构
    add_edge(1, 2, 4);    // A-B:4
    add_edge(1, 3, 2);    // A-C:2
    add_edge(2, 3, 5);    // B-C:5
    add_edge(2, 4, 10);   // B-D:10
    add_edge(3, 5, 3);    // C-E:3
    add_edge(5, 4, 4);    // E-D:4
    add_edge(4, 6, 11);   // D-F:11
    add_edge(5, 6, 5);    // E-F:5

    int s = 1;    // 起点A
    auto [dist, parent] = dijkstra(n, adj, s);

    // 输出所有最短路径
    for (int v = 1; v <= n; ++v) {
        if (dist[v] >= INF/2) {
            cout << "A -> " << v << " : INF (unreachable)\n";
        } else {
            cout << "A -> " << v << " : " << dist[v] << " , path: ";
            auto path = get_path(v, parent);
            for (int i = 0; i < (int)path.size(); ++i) {
                if (i) cout << " -> ";
                cout << (char)('A' + path[i] - 1);
            }
            cout << "\n";
        }
    }
    return 0;
}
```

### 实现要点说明

1. ​**优先队列**​：使用小根堆来高效获取当前最小距离顶点
    
2. ​**懒删除技术**​：通过判断`if (d != dist[u])`来跳过过时的队列条目
    
3. ​**路径还原**​：通过parent数组回溯得到完整路径
    
4. ​**溢出防护**​：使用long long类型防止大数计算溢出
    
5. ​**无向图处理**​：每条边需要双向添加到邻接表
    

## 6. 手算示例详解

### 示例图结构

顶点：A(1), B(2), C(3), D(4), E(5), F(6)

边及权重：

- A-B:4
    
- A-C:2
    
- B-C:5
    
- B-D:10
    
- C-E:3
    
- E-D:4
    
- D-F:11
    
- E-F:5
    

起点：A(1)

### 逐步执行过程

​**初始化**​：

- dist[A]=0，其他为∞
    
- parent全为-1
    
- 优先队列：{(0,A)}
    

​**Step 1：处理A(0)​**​

- 取出A(0)
    
- 松弛邻边：
    
    - B：dist[B]=∞→4，parent[B]=A
        
    - C：dist[C]=∞→2，parent[C]=A
        
    
- 队列：{(2,C), (4,B)}
    

​**Step 2：处理C(2)​**​

- 取出C(2)
    
- 松弛邻边：
    
    - B：4 vs 2+5=7 → 不更新
        
    - E：dist[E]=∞→5，parent[E]=C
        
    
- 队列：{(4,B), (5,E)}
    

​**Step 3：处理B(4)​**​

- 取出B(4)
    
- 松弛邻边：
    
    - D：dist[D]=∞→14，parent[D]=B
        
    
- 队列：{(5,E), (14,D)}
    

​**Step 4：处理E(5)​**​

- 取出E(5)
    
- 松弛邻边：
    
    - D：14 vs 5+4=9 → 更新dist[D]=9，parent[D]=E
        
    - F：dist[F]=∞→10，parent[F]=E
        
    
- 队列：{(9,D), (10,F)}
    

​**Step 5：处理D(9)​**​

- 取出D(9)
    
- 松弛邻边：
    
    - F：10 vs 9+11=20 → 不更新
        
    
- 队列：{(10,F)}
    

​**Step 6：处理F(10)​**​

- 取出F(10)
    
- 无邻边需要松弛
    
- 队列空，算法结束
    

### 最终结果

|目标顶点|最短距离|路径|
|---|---|---|
|A|0|A|
|B|4|A→B|
|C|2|A→C|
|D|9|A→C→E→D|
|E|5|A→C→E|
|F|10|A→C→E→F|

## 7. 实战技巧与注意事项

1. ​**负权边检测**​：如果图中可能存在负权边，应先检查或使用Bellman-Ford算法
    
2. ​**提前终止**​：如果只需要到特定终点的最短路径，可以在该终点被取出时终止算法
    
3. ​**多源最短路径**​：可以将多个源点的dist初始化为0并同时加入优先队列
    
4. ​**大数处理**​：
    
    - 使用long long防止溢出
        
    - 设置足够大的INF值（如4e18）
        
    
5. ​**性能优化**​：
    
    - 对于稠密图，考虑使用邻接矩阵+朴素实现(O(V²))
        
    - 对于稀疏图，优先队列实现更优
        
    
6. ​**图连通性**​：
    
    - 不可达顶点保持dist为INF
        
    - 可通过检查parent是否为-1判断连通性
        
    
7. ​**路径还原验证**​：
    
    - 确保路径的第一个顶点是起点
        
    - 检查路径长度是否与dist值一致
        
    

## 8. 变体与扩展

1. ​**有向图版本**​：只需单向添加边到邻接表
    
2. ​**指定终点优化**​：添加终点检查提前终止
    
3. ​**K最短路径**​：修改算法记录前K短路径
    
4. ​**双权值问题**​：同时考虑两种权重（如距离和费用）
    

## 9. 常见问题解答

​**Q1：为什么Dijkstra不能处理负权边？​**​

A1：负权边会破坏贪心选择性质，可能导致已确定的最短路径被后续更新推翻。

​**Q2：如何判断图中是否存在负权环？​**​

A2：使用Bellman-Ford算法，如果在V-1次松弛后还能继续松弛，则存在负权环。

​**Q3：Dijkstra和BFS有什么区别？​**​

A3：

- BFS适用于无权图或权值相同的图，使用普通队列
    
- Dijkstra适用于加权图，使用优先队列
    
- 当所有权重为1时，Dijkstra退化为BFS
    

​**Q4：如何处理大规模图的存储？​**​

A4：对于超大规模图，可以考虑：

- 使用邻接表+外部存储
    
- 分布式图计算框架
    
- 内存映射文件技术




## 这些符号到底是什么？

- **`dist[x]`**：当前已知的“起点 → x”的最短距离估计（开始时 `dist[s]=0`，其他都是 ∞）。
    
- **`d`**：从优先队列里**弹出**的那一项携带的距离值；在有效弹出时它等于 `dist[u]`。常见写法：
    
    ```cpp
    auto [d, u] = pq.top(); pq.pop();
    if (d != dist[u]) continue; // 丢旧条目
    ```
    
- **`w`**：一条边的**权重**，比如在邻接表里迭代 `u` 的邻居时得到的 `w(u,v)`：
    
    ```cpp
    for (auto [v, w] : adj[u]) { ... }
    ```
    
- 所以“`if (dist[v] > d + w)`”里的 `d` 实际上就是 `dist[u]`（当这次弹出是有效的），`w` 是边 `u→v` 的权重。
    

## “未确定/已确定”是什么意思？

- **已确定（settled）**：已经被从小根堆里**弹出**并通过了 `d == dist[u]` 检查的点 `u`。因为所有边权非负，此时 `dist[u]` 就是最终答案，以后不会再变。
    
- **未确定（unsettled）**：还没被这样弹出的点。它们的 `dist[]` 只是“当前最好估计”，还有可能被更新。
    

你可以把“已确定集合 SS”想成“**最短路已敲定**的点的集合”；每次都把“未确定里 `dist` 最小”的点加入 SS。

## 一眼看懂的流程（对应到代码）

1. 初始化：`dist[s]=0`，其他为 ∞；把 `(0, s)` 入堆。
    
2. 反复：
    
    - 从堆取出 `(d,u)`；若 `d != dist[u]` 跳过（这是**懒删除**，防止堆里残留旧值）。
        
    - 扫描 `u` 的所有邻居 `(v, w)`，做**松弛**：
        
        ```cpp
        if (dist[v] > dist[u] + w) { // 等价于用 d 也行
            dist[v] = dist[u] + w;
            parent[v] = u;
            pq.push({dist[v], v});
        }
        ```
        
    - 当某个终点 `t` 第一次被弹出时，若只关心 `s→t`，即可提前结束。
        

## 超小例子（只看一两步，理解 d、w、未确定）

图：A 为起点，边 A–B:4，A–C:2，C–D:3（全是非负）

- 初始化：`dist[A]=0`，其余 ∞；堆 = `[(0,A)]`，已确定集 S 为空。
    
- 弹出 **A**：得到 `d=0, u=A`（A 进入 S）
    
    - 邻居：
        
        - B：`∞ > 0 + 4` ⇒ `dist[B]=4`，入堆 `(4,B)`
            
        - C：`∞ > 0 + 2` ⇒ `dist[C]=2`，入堆 `(2,C)`
            
    - 堆现在是 `[(2,C), (4,B)]`（未确定最小的是 C）
        
- 弹出 **C**：`d=2, u=C`（C 进入 S）
    
    - 邻居：
        
        - D：`∞ > 2 + 3` ⇒ `dist[D]=5`，入堆 `(5,D)`
            
        - （若有 C–B 边也会比较 `4` vs `2+?`，不变或变短）
            
- 此时 A、C 已确定；B、D 未确定。接着会弹出 B（4）或 D（5）继续松弛。
    

看到没：`d` 就是“这次弹出的那个点的当前最短距离”；`w` 来自“正在看的那条边”；“未确定里最小的点”就是堆顶。

# 优先队列（priority_queue）

**它是什么？**  
一个能**快速取出“当前最小（或最大）”元素**的数据结构。Dijkstra 里我们要反复取“**未确定里 dist 最小**”的点，所以用**小根堆**优先队列最合适。

**在 Dijkstra 里起什么作用？**

- 存放“候选点”（还没被“确定”的点）以及它们当前的距离估计 `dist[x]`。
    
- 每次 `pop` 出堆顶，就是“未确定里最小的那个点”。
    
- 这样每一步都是 O(log⁡V)O(\log V) 地找到下一个要“确定”的点。
    

**我们需要维护吗？**  
要，但很轻量：

- **入堆（push）**：当你把起点 `(0, s)` 放进去；或者松弛成功时把 `(dist[v], v)` 放进去。
    
- **出堆（pop）**：每轮取出一个 `(d, u)` 来松弛 `u` 的邻居。
    
- 不需要“改堆里已有条目”的值——工程里常用**懒删除**：再推入一条新距离，等旧条目被弹出时用 `if (d != dist[u]) continue;` 丢弃即可。
    

**C++ 典型形态（小根堆）**

```cpp
using P = pair<long long,int>;              // {dist, node}
priority_queue<P, vector<P>, greater<P>> pq;

pq.push({0, s});                            // 入堆
auto [d, u] = pq.top(); pq.pop();           // 出堆
if (d != dist[u]) continue;                 // 懒删除旧条目
```

---

# 邻接表（adjacency list）

**它是什么？**  
一种**存图**的方式。对每个顶点 `u`，保存一个“邻居列表”，列表里放 `(v, w)` 表示有一条 `u → v` 的边，权重是 `w`。

**在 Dijkstra 里起什么作用？**

- 当我们“确定”了某个点 `u` 后，要**枚举 u 的所有邻边**去做松弛：  
    `for (auto [v, w] : adj[u]) { ... }`
    
- 因为只遍历到达得了的边，邻接表在**稀疏图**上比邻接矩阵更省时省内存。
    

**我们需要维护吗？**

- **建图阶段**维护一次（读输入或用 `add_edge` 加边）；
    
- 跑 Dijkstra 期间**不改动**邻接表（图结构是固定的），只是读它来遍历邻居。
    

**C++ 典型形态**

```cpp
int n = /* 顶点数 */;
// adj[u] 里放若干 {v, w}
vector<vector<pair<int,int>>> adj(n + 1);

auto add_edge_directed = [&](int u, int v, int w){
    adj[u].push_back({v, w});              // 有向边 u -> v
};
auto add_edge_undirected = [&](int u, int v, int w){
    adj[u].push_back({v, w});              // 无向边要加两次
    adj[v].push_back({u, w});
};
```

- **空间复杂度**：O(V+E)O(V+E)。
    
- **遍历某点 u 的代价**与它的度数成正比（u 的邻边条数）。
    

---

# 它们如何“配合工作”？

1. **邻接表**负责“告诉”算法：从 `u` 出发有哪些边 `(u→v, w)` 可以松弛。
    
2. **优先队列**负责“快速找到”下一步要处理的点 —— 当前 `dist` 最小的未确定点。
    
3. 算法主循环就成了：
    
    - `pq.pop()` 拿到 `(d,u)`；若 `d != dist[u]` 丢弃。
        
    - 枚举 `adj[u]` 里的 `(v,w)`，做 `if (dist[v] > dist[u] + w)` 更新，并 `pq.push({dist[v], v})`。
        

---

# 小例子：它们各自长什么样

图（无向）：  
A(1)–B(2):4，A(1)–C(3):2，C(3)–E(5):3，E(5)–D(4):4，E(5)–F(6):5，B(2)–D(4):10，D(4)–F(6):11

**邻接表**（只展示部分）：

```
adj[1] = {(2,4), (3,2)}
adj[2] = {(1,4), (3,5), (4,10)}
adj[3] = {(1,2), (2,5), (5,3)}
adj[4] = {(2,10), (5,4), (6,11)}
adj[5] = {(3,3), (4,4), (6,5)}
adj[6] = {(4,11), (5,5)}
```

**优先队列**（运行初期的内容演化，展示堆里保存的 `(dist, node)`）：

```
初始: [(0,1)]
弹出(0,1)，松弛后推入: (4,2), (2,3)
堆: [(2,3), (4,2)]
弹出(2,3)，松弛后推入: (5,5) 以及可能的其他更新
堆: [(4,2), (5,5), ...]
...
```

你能直观看到：邻接表是**静态的“图结构”**；优先队列是**动态的“就绪队列”**。

---

# 可替代与拓展

- **邻接矩阵**：`int g[n+1][n+1]`，遍历邻居要扫一整行，适用于**非常稠密**或 nn 很小的图；复杂度 O(V2)O(V^2)。
    
- **`set`/`multiset`** 代替优先队列并**手动 decrease-key**：代码更复杂但能避免懒删除；通常 `priority_queue + 懒删除` 已够用。
    
- **二叉堆 vs 斐波那契堆**：理论上斐波那契堆 O(E+Vlog⁡V)O(E + V\log V)，工程里二叉堆（`priority_queue`）更简单、常见。
    

---

**结论先说：**

- **优先队列（Priority Queue）**是一个“抽象数据类型（ADT）”，只规定操作：插入、取极值（最小或最大）、删除极值，复杂度最好是 O(log⁡n)O(\log n)。
    
- **小根堆（min-heap）**是实现优先队列的一种常见**数据结构**。所以“优先队列 ≈ 接口”，“小根堆 ≈ 常用实现”。
    

你记得“**小根堆用数组存**”是对的：**二叉堆**通常用一段连续内存（数组/`vector`）存储，通过下标当“指针”：

- 若用**0-based**：`parent(i)=(i-1)/2`，`left(i)=2*i+1`，`right(i)=2*i+2`
    
- 维护堆序性（父 ≤ 子），取最小值就是 `a[0]`（O(1)O(1)），插入/删除极值重排堆是 O(log⁡n)O(\log n)。
    

在 **C++** 里：

- `std::priority_queue` 默认是**大根堆**（取最大）。要小根堆，给个比较器：
    
    ```cpp
    priority_queue<int, vector<int>, greater<int>> pq; // 小根堆
    ```
    
- 底层默认容器是 `vector`（动态数组），并用 `<algorithm>` 的 `push_heap/pop_heap/make_heap` 来维护**数组上的二叉堆**。
    
- 这也解释了为什么它**没有 decrease-key** 操作；Dijkstra 里常用“**懒删除**”（再次 push 新的更小距离，弹出时丢弃旧条目）。
    

如果你想“手撸一个数组堆”，也很简单（展示小根堆三件套用法）：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> heap;                          // 动态数组 = 堆存储
    auto cmp = greater<int>();                 // 小根堆

    // 建堆
    heap = {7, 3, 9, 1};
    make_heap(heap.begin(), heap.end(), cmp);

    // 插入（push）
    heap.push_back(2);
    push_heap(heap.begin(), heap.end(), cmp);

    // 取/删最小（top+pop）
    pop_heap(heap.begin(), heap.end(), cmp);   // 最小值被交换到末尾
    int mn = heap.back();                      // 取出最小值
    heap.pop_back();                           // 真正删除
}
```

**小结：**

- “优先队列不是=小根堆”，但**最常见的优先队列实现就是（数组上的）二叉小根堆**。
    
- 也可以用**多叉堆、配对堆、斐波那契堆、平衡树（`multiset`）**等实现优先队列，只是工程上二叉堆最简单高效。