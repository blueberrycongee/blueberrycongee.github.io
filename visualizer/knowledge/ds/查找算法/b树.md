# 计算机笔记整理：高级搜索树 (二) B 树

> [!NOTE] 课程概要
> 
> 本节课的核心内容是 B 树。
> 
> - **前置内容**：跳过 "BST Application" (二叉搜索树应用) 章节，包括区间树、k-d tree、线段树等。
>     
> - **跳过原因**：该章节非考试重点（历年未考），占分极少。
>     
> - **本节安排**：1. 讲解 B 树；2. 完成 5 道练习题（3 道生成树，2 道 B 树）。
>     

---

## 🌳 B 树的引入与动机

### 1. 为什么需要 B 树？(I/O 瓶颈)

- **问题背景**：虽然内存 (Memory) 增长很快，但应用问题的规模（数据量）增长得更快。
    
    - _例子_：以前 2G 内存的手机不卡，现在 8G 内存的手机也卡，因为应用（如微信、图片、视频）消耗的资源越来越多。
        
    
- **核心矛盾**：内存速度快，但外存（磁盘）速度慢。
    
    - 一次 I/O (磁盘读写) 操作的时间，足够在内存中进行成千上万次查找。
        
    - 对于超大规模数据，如果使用 AVL 树等平衡二叉树，树高可能达到 30 层，意味着需要 30 次 I/O 操作，这是无法接受的。
        
    

### 2. B 树的核心思想：分级存储与批量访问

B 树的设计目标是 **最小化 I/O 操作次数**。

- **分级存储 (Hierarchical Storage)**：
    
    - 内存可以视为外存的缓存 (Cache)。
        
    - CPU 内部也有 Cache（高速缓存），用于缓存近期访问的内存数据。
        
    
- **数据访问的局部性**：程序倾向于在一段时间内集中访问特定区域的数据。
    
- **I/O 的批量特性**：
    
    - 外存（磁盘）读写是按 “数据块” (Data Block) 进行的。
        
    - 读 1 字节 (Byte) 和读 1 千字节 (1 KB) 的时间几乎一样快。
        
    - 系统（如数据库）进行一次 I/O，通常会固定读取一个数据块（例如 4KB）。
        
    - 如果你只读 1 字节，系统也会把其所在的 4KB 数据块全部从外存搬到内存。
        
    
- **B 树的解决方案**：
    
    - **减少 I/O 次数**：既然一次 I/O 必须读 4KB，那就让这 4KB 容纳尽可能多的信息。
        
    - **超级节点 (Super Node)**：B 树将一个节点设计得非常“胖”，使其大小约等于一个磁盘块（例如 4KB）。
        
    - **批量加载**：一次 I/O 将这整个“超级节点”（包含大量关键码）从外存读入内存。
        
    - **内存查找**：在内存中（非常快地）遍历这个节点内的几百个关键码，找到正确的下一层分支。
        
    

> [!QUOTE] 核心准则
> 
> "宁愿在内存当中找 1000 次，也不做一次 I/O。"

- **效果**：通过增大节点容量（提高树的“度” `m`），B 树极大地压缩了树的高度。
    
    - _例如_：若 `m = 256`（在数据库中很常见），原本 30 次 I/O 的查找可以被压缩到 4 次 I/O。
        
    

---

## 📊 B 树的定义与性质

### 3. B 树的定义 (M 阶 B 树)

- B 树是一种 **平衡的多路搜索树**(Balanced Multi-way Search Tree)。
    
- 它在逻辑上与平衡二叉搜索树 (BBST) 完全等价，但结构上不是二叉的。
    
- **M 阶 (Order m) B 树**：`m`定义了节点分支数的 **上限**。
    
    - _邓老师定义_：`m >= 3`。 (注：其他教材可能定义 `m >= 2`)。
        
    

### 4. B 树的性质

#### (1) 节点定义

B 树的节点分为内部节点、叶子节点和外部节点。

- **内部节点 (Internal Nodes)**：
    
    - **根节点 (Root)**：
        
        - 可以只有一个关键码（即两个分支）。
            
        - 这是为了允许树在分裂 (split) 时能生成新的根。
            
        
    - **非根内部节点**：
        
        - 设节点有 `n`个关键码。
            
        - **关键码数量**：`ceil(m/2) - 1 <= n <= m - 1`。
            
        - **分支数量**：`n + 1`。
            
        - **分支数量范围**：`ceil(m/2) <= (n+1) <= m`。
            
        
    
- **叶子节点 (Leaf Nodes)**：
    
    - 指 **最底层的、包含关键码**的节点。
        
    - 其深度统一为 `h - 1`。
        
    - 叶子节点 _不是_外部节点。
        
    
- **外部节点 (External Nodes)**：
    
    - 指逻辑上存在的“失败节点”（相当于二叉树的 `NULL`指针）。
        
    - 它们不包含任何关键码信息。
        
    - 所有外部节点必须在 **同一深度**，即深度 `h`。
        
    

> [!WARNING] B 树的高度 (Height) 定义
> 
> B 树的高度 `h`**必须计算外部节点**。
> 
> 这是一个极易混淆但非常明确的规定。如果树的叶子节点（含关键码）在第 3 层，那么外部节点就在第 4 层，树高 `h=4`。

#### (2) 结构性质

- **命名**：M 阶 B 树又常被称为 `(ceil(m/2), m)`树。
    
    - _例子_：5 阶 B 树 (`m=5`)，`ceil(5/2) = 3`。它是一个 (3, 5) 树，意味
        
        - 分支数（非根）：`[3, 5]`
            
        - 关键码数（非根）：`[2, 4]`
            
        
    
- **4 阶 B 树**：(也称 (2, 4) 树) 的研究对后续理解红黑树大有裨益。
    
- **表示法**：
    
    - **紧凑表示**：不画出外部节点，但必须清楚它们逻辑上存在。
        
    - **详细表示**：画出指向关键码和子节点的指针。
        
    

### 5. ※ B 树 vs M 叉树 (M-ary Tree)

- **M 叉树**：一个 M 叉树必须（至少有一个节点）有 `m`个分支。
    
- **M 阶 B 树**：`m`只是分支数的 **上限**。
    
    - _例子_：一个 5 阶 B 树，其所有节点都可能只有 3 个分支，它依然是一个合法的 5 阶 B 树 (3-5 树)，但你不能称它为 5 叉树。
        
    

---

## ⚙️ B 树的操作与性能

### 6. B 树的查找 (Search)

1. **起始**：从根节点开始（根节点默认常驻内存）。
    
2. **节点内查找**：
    
    - 在当前节点（已在内存中）的关键码中进行 **顺序查找**。
        
    
    > (注：虽然 PPT 提到二分查找，但实际应用中，由于 `m`不会无限大且顺序访问对 Cache 友好，顺序查找效率可能更高)。
    
3. **分支**：
    
    - **若找到**：返回查找成功。
        
    - **若未找到**：根据比较结果，确定要访问的下一层子节点。
        
    
4. **I/O 操作**：
    
    - 如果该子节点不在内存中，执行一次 **I/O 操作**，将其从外存读入内存。
        
    
5. **终止**：
    
    - **若到达外部节点**：说明查找失败。
        
    - _例子_：查找 75 (命中)；查找 19 (I/O 1 次, 命中)；查找 49 (I/O 2 次, 命中)；查找 5 (I/O 2 次, 到达外部节点, 失败)。
        
    

### 7. B 树的高度 (Height) - 考点

B 树的性能（I/O 次数）完全取决于其 **高度 `h`**。

> [!IMPORTANT] B 树高度公式 (N 个关键码, M 阶)
> 
> 1. **最小高度 (最“胖”的树)**：
>     
>     - 假设：除根外，每个节点都 **填满**(`m-1`个关键码)。
>         
>     - 公式：**h≥⌈logm​(n+1)⌉**
>         
>     
> 2. **最大高度 (最“瘦”的树)**：
>     
>     - 假设：除根外，每个节点都 **最少**(`ceil(m/2)-1`个关键码)。
>         
>     - 令 t=⌈m/2⌉(即最小分支数)。
>         
>     - 公式：**h≤1+⌊logt​(2n+1​)⌋**
>         
>     
> 
> **注意**：
> 
> - 公式中的 `+1`和取整 (ceil/floor) 是因为 `h`必须是整数。
>     
> - 这些公式是考试重点，必须熟记，或者至少要能现场推导。
>     

### 8. B 树的插入 (Insertion)

- **考试说明**：B 树的插入和删除 **历年（866）未考**，但是一个 **极有可能考**的考点。
    
- **插入位置**：插入操作永远发生在 **叶子节点**(深度 `h-1`)。
    
- **查找**：首先执行“查找”操作，找到目标关键码应插入的叶子节点。
    

#### (1) Case 1: 叶子节点未满

- 如果该叶子节点所含关键码数量 `< m-1`。
    
- **操作**：直接将新关键码插入到该节点的有序序列中。
    

#### (2) Case 2: 叶子节点已满 (Overflow)

- 如果该叶子节点已有 `m-1`个关键码。
    
- **操作：分裂 (Split)**。
    
    1. **假插入**：将新关键码按顺序插入该节点，使其暂时拥有 `m`个关键码（上溢）。
        
    2. **找中位数**：从 `m`个关键码中选取中位数 `k`。
        
        - 若 `m`为奇数：取最中间的那个 (例如 3 个key `(k_0, k_1, k_2)`，取 `k_1`)。
            
        - 若 `m`为偶数：取 "中间偏右" 的那个 (例如 6 个key，取第 4 个)。
            
        - (综合来看，通常是取第 `floor(m/2)`个索引位置的 key)
            
        
    3. **提升 (Promote)**：将该中位数关键码 `k`**提升**到其 **父节点**中。
        
    4. **分裂**：原节点以 `k`为界，分裂成两个新节点（左、右兄弟），分别包含 `k`左侧和右侧的关键码。
        
    5. 这两个新节点成为父节点中 `k`的左右孩子。
        
    

#### (3) 级联分裂 (Cascading Split)

- 当关键码 `k`被提升到父节点时，如果 **父节点也满了**，则父节点也会发生 "Overflow"。
    
- **操作**：对父节点 **重复执行上述分裂 (Split) 过程**。
    
- 这个过程可能一路向上传播，直到根节点。
    
- **分裂到根**：如果根节点分裂，会生成一个新的根节点。
    
    - 这个新的根节点只包含 **1 个**被提升上来的关键码。
        
    - 这就是为什么 B 树允许根节点只有 1 个关键码（2 个分支）。
        
    
- _例子_：
    
    - `m=3`(最多 2 个 key)。插入 29，导致 `(19, 23, 29)`上溢，`23`提升。
        
    - `m=3`。插入 45，导致 `(41, 45, 51)`上溢，`45`提升；父节点变为 `(23, 36, 45)`再次上溢，`36`提升，成为新根。
        
    

### 9. B 树的删除 (Deletion)

删除操作比插入更复杂。

#### (1) 步骤 1: 确保在叶子节点删除

- **查找**：首先找到包含目标关键码 `k`的节点 `v`。
    
- **如果 `k`在内部节点**：
    
    - **操作**：不能直接删除。需要将 `k`与其 **中序后继 (in-order successor)**（或前驱）进行交换。
        
    - **重要结论**：`k`的中序后继 **必定位于叶子节点**。
        
    - **转换**：交换后，问题转化为“在叶子节点中删除 `k`的后继”。
        
    
- **如果 `k`在叶子节点**：直接进入步骤 2。
    

#### (2) 步骤 2: 从叶子节点删除

- 从叶子节点 `v`中删除关键码 `k`。
    
- **Case A: 节点未下溢 (No Underflow)**
    
    - 删除 `k`后，节点 `v`的关键码数量仍然 `> = ceil(m/2) - 1`。
        
    - **操作**：删除完成，B 树性质仍然满足。
        
    
- **Case B: 节点下溢 (Underflow)**
    
    - 删除 `k`后，节点 `v`的关键码数量 `< ceil(m/2) - 1`。
        
    - **操作**：必须进行 **下移修复 (Solve Underflow)**。
        
    

#### (3) 步骤 3: 下移修复 (Fix-Up)

当节点 `v`发生下溢时，查看其 **左右兄弟**节点 `L`和 `R`。

> (注：兄弟节点的“贫富”比喻：
> 
> - “富余” (够借)：关键码数量 > `ceil(m/2) - 1`
>     
> - “贫穷” (不够借)：关键码数量 = `ceil(m/2) - 1`)
>     

- **Case 1: 旋转 (Rotation) - 兄弟“富余”**
    
    - 如果 `v`的左兄弟 `L`(或右兄弟 `R`) “富余”。
        
    - **操作**：从“富余”的兄弟处“借”一个关键码。
        
    - **旋转过程**(以向左兄弟借为例)：
        
        1. 父节点中、分隔 `L`和 `v`的关键码 `y`**向下**移入 `v`。
            
        2. `L`中最大的关键码 `x`**向上**移入父节点，替换 `y`。
            
        
    - _例子_：`m=3`(min key=1)。删除 75，节点 `(75)`变 `()`下溢。右兄弟 `(79, 84)`富余 (有 2 > 1)。
        
        1. 父 key `77`**下移**到 `v`，`v`变为 `(77)`。
            
        2. 兄弟 key `79`**上移**到父，父变为 `(79)`。
            
        3. 兄弟变为 `(84)`。修复完成。
            
        
    
- **Case 2: 合并 (Merge) - 兄弟“贫穷”**
    
    - 如果 `v`的左、右兄弟（或存在的那个兄弟）都“贫穷”。
        
    - **操作**：无法旋转，只能将 `v`与其中一个兄弟（例如左兄弟 `L`）合并。
        
    - **合并过程**：
        
        1. 父节点中、分隔 `L`和 `v`的关键码 `y`**向下**移入 `L`(或 `v`)，作为“粘合剂” (Glue)。
            
        2. 将 `v`中剩余的关键码全部移入 `L`(或 `L`移入 `v`)。
            
        3. `v`节点被删除。
            
        
    - _例子_：`m=3`。删除 84，节点 `(84)`变 `()`下溢。左兄弟 `(79)`贫穷 (min=1)。右兄弟 `(97)`也贫穷 (min=1)。
        
        1. (PPT 演示了与右兄弟合并)
            
        2. 父 key `89`**下移**作为粘合剂。
            
        3. `()`与 `89`与 `(97)`合并，新节点为 `(89, 97)`。
            
        4. 父节点 `(79, 89)`失去 `89`，变为 `(79)`。
            
        
    

#### (4) 步骤 4: 级联下溢 (Cascading Underflow)

- **Case 2 (合并)**会从父节点“拉”下来一个关键码。
    
- 这可能导致 **父节点**发生下溢 (Underflow)。
    
- **操作**：如果父节点下溢，对其 **递归执行步骤 3 (下移修复)**。
    
- 此过程可能一直向上传播，直到根节点。
    
- _例子_：删除 51，导致 `(19)`和 `()`合并，父 `(36)`下移，父节点 `(23, 36)`变为 `(23)`，发生下溢。父节点 `(23)`再与兄弟 `(79)`合并，根 `(53)`下移，导致树高降低。
    

> [!NOTE] PPT 与代码的不一致
> 
> - 在删除 84 的例子中，PPT 演示了与 **右兄弟**合并。
>     
> - 而标准代码实现通常 **优先与左兄弟**交互（旋转或合并）。
>     
> - 这两种处理都正确，只是策略不同，考试时若非指定，两种都应算对。
>     

---

## 💡 补充与考情

### 10. ※ 补充：三路反转法 (循环左移)

- (注：此内容在邓老师课程中位于“绪论”，但在 B 树章节被提及，因其体现了“缓存”思想)
    
- **问题**：将数组 `AB`转换为 `BA`(循环左移)。
    
- **算法**：(A, B 分别代表数组的两部分)
    
    1. `A`翻转 (Reverse) -> `A^r`
        
    2. `B`翻转 (Reverse) -> `B^r`
        
    3. 整体 `A^r B^r`翻转 (Reverse) -> `(A^r B^r)^r`= `BA`
        
    
- _例子_：`[0 1 2 3 | 4 5 6 7 8 9]`
    
    1. `[3 2 1 0 | 4 5 6 7 8 9]`
        
    2. `[3 2 1 0 | 9 8 7 6 5 4]`
        
    3. `[4 5 6 7 8 9 | 0 1 2 3]`
        
    
- **意义**：虽然算法复杂度系数看似更高（翻转三次），但它能更充分地利用缓存 (Cache)，实际运行时间可能更短。
    

### 11. 课程与考情提示

- **PPT 版本问题**：新版 PPT (如 24, 25 版) 可能会删减旧版 PPT 的内容。
    
- **风险**：不要盲目追新。被删除的内容仍有可能是考点。
    
- **历史案例**：2019 年考研真题中有一个关于“为什么中缀表达式转逆波兰表达式 (RPN) 的过程中就能算出结果，还要转 RPN” 的问题。
    
- **出处**：这个问题在 2017 版的 PPT 中有，但在当时（2019年）的新版 PPT 中已被删除。