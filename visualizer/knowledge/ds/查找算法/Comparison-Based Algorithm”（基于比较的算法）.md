[[顺序查找]]

[[二分查找]]

[[插值查找]]

[[BST二叉搜索树or二叉排序树]]

[[AVL树]]

[[伸展树]]

[[红黑树]]

用 CBA 式的排序算法对所有大小为 n 的数组进行排序,其时间复杂度是 Ω(nlogn).（ ） （2018）

CBA 式算法可以在 O(n)内从任意 n 个整数中找出中位数.（ ）（2025）




**Comparison-Based Algorithms (CBA)**，即基于比较的算法，是一种通过比较元素来决定其相对顺序的算法。这类算法的主要特征是它们的运行时间通常与输入数据的大小相关，并且会受到数据的比较次数影响。以下是基于比较的算法的主要知识点和概述：

### 1. **基本概念**

基于比较的算法依赖于“比较”操作来排序或选择元素。在这种算法中，元素的相对顺序由比较结果决定（例如，判断一个元素是否大于另一个元素）。例如，常见的排序算法（如快速排序、归并排序、堆排序）都属于基于比较的算法。

### 2. **时间复杂度的下界**

对于任何基于比较的排序算法，**时间复杂度的下界是Ω(n log n)**，即任何比较排序算法在最坏情况下都需要至少O(n log n)的时间。这个下界由**决策树**理论推导出来，即在最坏情况下，排序过程需要进行log₂(n!)次比较，而log₂(n!) ≈ n log n。

- **证明**：假设有n个元素，排序的过程中通过比较决定元素的顺序。这个过程等同于构建一个**决策树**，树的高度决定了最坏情况下所需的比较次数。树的每一层代表一次比较，每个节点代表一个可能的比较结果。树的总高度等于所有可能排列的对数，即log₂(n!) ≈ n log n，因此最少需要Ω(n log n)次比较才能完成排序。
    

### 3. **中位数问题的复杂度**

对于“从任意n个整数中找出中位数”这一问题，**基于比较的算法可以在O(n)内找到中位数**。这是因为我们可以使用**选择算法**，如**快速选择算法**（QuickSelect），通过对数组进行部分排序来在O(n)时间内找出中位数。

- **快速选择算法**：基于快速排序的思想，它通过选择一个“枢轴”元素来将数组分为两部分，然后根据中位数所在的部分继续递归处理。不同于快速排序，快速选择只递归处理可能包含中位数的那一部分，因此它的时间复杂度在最坏情况下为O(n)。
    

### 4. **排序算法的时间复杂度**

**基于比较的排序算法的时间复杂度是Ω(n log n)**，并且这也是最优的时间复杂度。例如，快速排序、归并排序、堆排序等排序算法的时间复杂度在最坏情况下都是Ω(n log n)。

- **归并排序**和**堆排序**的时间复杂度是O(n log n)。
    
- **快速排序**的平均时间复杂度是O(n log n)，但最坏情况是O(n²)（当数组已经排序或逆序时）。
    

### 5. **总结**

- 基于比较的算法的核心是通过元素之间的比较来决定它们的顺序或选择特定元素。
    
- **时间复杂度下界**：任何基于比较的排序算法在最坏情况下需要Ω(n log n)次比较。
    
- 通过选择算法，基于比较的算法可以在**O(n)**时间内找到中位数。
    
- 对于所有基于比较的排序算法，其时间复杂度在最坏情况下是Ω(n log n)。
    

### 6. **判断题解答**

1. **CBA式算法可以在O(n)内从任意n个整数中找出中位数**：正确。可以使用选择算法（如快速选择算法），其在最坏情况下的时间复杂度为O(n)。
    
2. **用CBA式的排序算法对所有大小为n的数组进行排序,其时间复杂度是Ω(n log n)**：正确。任何基于比较的排序算法（如归并排序、快速排序等）在最坏情况下的时间复杂度为Ω(n log n)，因此这是基于比较的排序的下界。