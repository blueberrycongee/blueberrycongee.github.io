# 插值查找（C++实现）

## 1. 基本概念

插值查找（Interpolation Search）是二分查找的改进版本，根据查找键值与查找表中最大最小值的比较结果，按比例确定查找位置。

## 2. 核心思想

类比：在字典中查找单词

- 查"apple"时，会翻到前面
    
- 查"zebra"时，会翻到后面
    
- 不是每次都翻到中间
    

## 3. 计算公式

```
int pos = left + ((target - arr[left]) * (right - left)) / (arr[right] - arr[left]);
```

对比二分查找：

```
// 二分查找：固定取中点
int mid = left + (right - left) / 2;

// 插值查找：根据值的分布动态取点
int pos = left + ((target - arr[left]) * (right - left)) / (arr[right] - arr[left]);
```

## 4. 时间复杂度

- 最好情况：O(1)
    
- 平均情况：O(log log n) - 在均匀分布时
    
- 最坏情况：O(n) - 在极端不均匀分布时
    

## 5. 实现代码

```
int interpolationSearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right && arr[left] <= target && target <= arr[right]) {
        // 防止除零错误
        if (arr[left] == arr[right]) {
            if (arr[left] == target) {
                return left;
            } else {
                break;
            }
        }
        
        // 插值公式
        int pos = left + ((target - arr[left]) * (right - left)) / (arr[right] - arr[left]);
        
        // 边界检查
        if (pos < left) pos = left;
        if (pos > right) pos = right;
        
        if (arr[pos] == target) {
            return pos;
        } else if (arr[pos] < target) {
            left = pos + 1;
        } else {
            right = pos - 1;
        }
    }
    
    return -1;
}
```

## 6. 与二分查找对比

|特性|二分查找|插值查找|
|---|---|---|
|分割方式|固定中点|按值比例|
|均匀分布|O(log n)|O(log log n)|
|极端分布|O(log n)|O(n)|
|适用场景|通用|数据均匀分布|

## 7. 最佳使用场景

1. 数据分布均匀
    
2. 数据量较大
    
3. 查找操作频繁
    

## 8. 注意事项

1. 必须有序：和二分查找一样
    
2. 分布敏感：数据分布不均匀时性能下降
    
3. 溢出风险：计算pos时需要注意整数溢出
    
4. 边界检查：target必须在[arr[left], arr[right]]范围内
    

## 9. 相关主题

- 基于比较的算法（Comparison-Based Algorithm）
    
- 二分查找 - 基础版本
    
- 二叉搜索树（BST） - 树形查找结构
    

## 10. 思考题

Q: 为什么在均匀分布时，插值查找能达到O(log log n)？

A: 每次查找可以跳过更多不相关的元素，不是简单的对半分，而是按比例跳跃。