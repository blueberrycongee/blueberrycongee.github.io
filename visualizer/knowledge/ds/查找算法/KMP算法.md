# 
[[BF蛮力算法]]
[[BM算法-BC表]]
[[BM算法-GS表]]
# 串匹配（KMP 专场）

---

## 2) BF 回顾与复杂度口径
- 问题：在文本 `T`（长 `n`）中找模式 `P`（长 `m`）。  
- BF 思想：逐位对齐、逐字比较，不等则**右移一位**重来。  
- **最好**：一上来就匹配到 → 比较约 `m` 次。  
- **最坏**：形如 `T = 000…0x`，`P = 000…0`，每次比 `m` 次再右移一位 → **O(n·m)**。  
- 课堂口径里还提到一个便于与 BM 对比的表述：**“最差场景下的最好时间”≈ Ω(n)**（为了对照 BM 的移动下界），但若单独谈 BF 的**最好情况**也可记 **O(m)** ——两种说法**不冲突，语境不同**。

---

## 3) BF 为何低效 → KMP 的直觉
- 已经比对成功的一段**信息没有被复用**，导致大量**重复比较**。  
- KMP 利用“**已匹配前缀 = 已匹配后缀**”的结构信息，**让模式串自身滑动到“值得对齐”的位置**：  
  - 失配发生在 `T[i]` vs `P[j]` 时，**`i` 不回退**；  
  - 令 `j = next[j]`，直接把“**最长真前后缀的后一个位置**”拿来与 `T[i]` 再比。

---

## 4) KMP 核心主循环（抽象）
- 典型写法（语义）：
  - 若 `j < 0` **或** `T[i] == P[j]`：`i++，j++`  
  - 否则：`j = next[j]`  
- 结论：**`i` 从不回退**，匹配总步数 ≤ `2n`，搜索阶段 **O(n)**。

---

## 5) 本课程版 `next` 表的**严格定义**（务必按这版记）
> **`next[j]` = 在子串 `P[0..j)`（不含 `P[j]`）中，“最长公共**真**前后缀”的长度**。  
> （不同教材定义可能略异，本课采用**不含 `P[j]`** 的写法。）

- **初值**（本课口径）：
  - `next[0] = -1`（约定，配合主循环使代码更顺畅）
  - `next[1] = 0`（`P[0..1)` 只有一个字符，其最长**真**前后缀为空串，长度 0）

> 失配时：`j ← next[j]`，等价于把 `P` 向右滑到“**前缀=后缀** 的最长位置”，立刻用 `P[next[j]]` 对齐 `T[i]` 继续比。

---

## 6) `next` 的构造思路与“传递链”
- 语义法（更适合人脑）：对每个 `j`，只看 `P[0..j)`，求其**最长公共真前后缀长度**。  
- 代码法（更适合电脑）：维护一个“已知最长真前后缀长度”指针 `k = next[j]`，比较 `P[j]` 与 `P[k]`；  
  - 相等则 `next[j+1] = k + 1`；  
  - 不等则 **`k = next[k]` 继续回溯**，这条回溯链就是你说的**“传递链”**。  
- 复杂度：**O(m)**（每个位置最多前进或回退有限次，总体线性）。

---

## 7) 课堂示例要点（记“方法”，不必死记答案）
- 示例 A：`… CHINCHI …`  
  - 在 `P[0..7)` 中，存在长度为 3 的公共真前后缀 `CHI` → **`next[7] = 3`**。  
  - 用意：展示**如何用“最长真前后缀”定位新的对齐点**。  
- 示例 B：`MAMAMIA`  
  - 前半段会逐步得到 `…, 0,1,2,3, …`；遇到新字符破坏规律时，通过**传递链回退**：可能从 3 → 1 → 0。  
  - 用意：展示**一旦失配，如何沿 `next` 链回退**直到找到可续接的位置或归零。

> 关键：**会算会解释**比记住具体数值更重要；考试更偏好“依据定义推导过程”。

---

## 8) 与 BM / KR 的对照与考点提醒
- **BM**：联合使用 **BC（坏字符）** + **GS（好后缀）** 两张表，**位移更激进**，但构造与实现明显更复杂；GS 的构造是难点。  
- **KR（Rabin–Karp）**：基于滚动哈希，思想简洁，冲突处理是要点。  
- **考点历史**：  
  - 见过 **KMP 改进 `next`（nextval）** 的构造题；  
  - 复杂度/语义判断题常见（如 `i` 是否回退、`next` 定义是否包含 `P[j]`、初始化取值）。  

---

## 9) 口袋卡（最后 30 秒复盘）
- `next[j]`（本课）：**最长公共真前后缀**，只看 `P[0..j)`。  
- 初值：`next[0] = -1`，`next[1] = 0`。  
- 主循环：`T[i]==P[j]` 或 `j<0` → `i++，j++`；否则 `j = next[j]`。  
- `i` **绝不回退**；搜索 **O(n)**，预处理 **O(m)**。  
- 失配后**对齐点**由“最长真前后缀”决定；**传递链** = 不断 `j = next[j]` 回溯。

# 手工“人推版”构造 KMP 的 `next`（普通版）

以模式串 **P = "ababaca"** 为例（长度 m=7）。  
本课口径：`next[j]` 定义为 **子串 `P[0..j)`（不含 `P[j]`）的“最长公共真前后缀”长度**。  
初值约定：`next[0] = -1`，`next[1] = 0`。

---

## 一、最适合人推的“列前后缀”法

**做法**：对每个 `j`（从 2 开始），只看 **`S = P[0..j)`**，把它的**真前缀**和**真后缀**列出来，找最长相等者的长度，就是 `next[j]`。

> P = a b a b a c a  
> idx: 0 1 2 3 4 5 6

### 1) `next[0] = -1`，`next[1] = 0`
- `P[0..1) = "a"`，只有空真前后缀 ⇒ 长度 0。

### 2) j = 2：`P[0..2) = "ab"`
- 真前缀：`"a"`
- 真后缀：`"b"`
- 最长公共真前后缀：无 ⇒ **`next[2] = 0`**

### 3) j = 3：`P[0..3) = "aba"`
- 真前缀：`"a"`, `"ab"`
- 真后缀：`"a"`, `"ba"`
- 公共者：`"a"` ⇒ 长度 1 ⇒ **`next[3] = 1`**

### 4) j = 4：`P[0..4) = "abab"`
- 真前缀：`"a"`, `"ab"`, `"aba"`
- 真后缀：`"b"`, `"ab"`, `"bab"`
- 公共者：`"ab"` ⇒ 长度 2 ⇒ **`next[4] = 2`**

### 5) j = 5：`P[0..5) = "ababa"`
- 真前缀：`"a"`, `"ab"`, `"aba"`, `"abab"`
- 真后缀：`"a"`, `"ba"`, `"aba"`, `"baba"`
- 公共者：`"aba"` ⇒ 长度 3 ⇒ **`next[5] = 3`**

### 6) j = 6：`P[0..6) = "ababac"`
- 真前缀：`"a"`, `"ab"`, `"aba"`, `"abab"`, `"ababa"`
- 真后缀：`"c"`, `"ac"`, `"bac"`, `"abac"`, `"babac"`
- 公共者：无 ⇒ **`next[6] = 0`**

### 7) j = 7：`P[0..7) = "ababaca"`
- 真前缀：`"a"`, `"ab"`, `"aba"`, `"abab"`, `"ababa"`, `"ababac"`
- 真后缀：`"a"`, `"ca"`, `"aca"`, `"baca"`, `"abaca"`, `"babaca"`
- 公共者：`"a"` ⇒ 长度 1 ⇒ **`next[7] = 1`**

**汇总：**
    P = a b a b a c a  
       j : 0 1 2 3 4 5 6 7  
next[j] : -1 0 0 1 2 3 0 1

题解：KMP 与蛮力算法在不同字符集下的效率

## 题目复述

> 7、字符集越大 KMP 算法和蛮力算法比越没有优势，对

## 核心原理解析

为了理解这个论点，我们首先要明白 KMP 算法和蛮力（Brute-Force, BF）算法各自的优势和劣势来源。

### 1. 蛮力算法 (Brute-Force, BF)

* **工作方式**：
    1.  将模式串 `P` (长度 $m$) 与文本串 `T` (长度 $n$) 的开头对齐。
    2.  逐个字符比较 `T[i]` 和 `P[j]`。
    3.  如果 `T[i] == P[j]`，则 `i` 和 `j` 都加 1。
    4.  如果 `T[i] != P[j]`（发生失配），文本串指针 `i` 回溯到本次匹配开始位置的**下一个**字符 (即 `i = i - j + 1`)，模式串指针 `j` 回溯到 `0`。
* **最坏情况**：$O(n \times m)$。
* **劣势来源 (何时最坏)**：当模式串和文本串有大量“部分匹配”时。
    * *例子*：在文本串 `T = "AAAAAAAAAB"` 中查找模式串 `P = "AAAAAB"`。
    * `BF` 算法会进行 5 次 `A` 的匹配，然后在第 6 个字符处失配 (`A` != `B`)。
    * 然后 `BF` 回溯，将 `P` 右移一位，再次进行 5 次 `A` 的匹配，再次失配...
    * 这种重复的“部分匹配”导致了 $O(n \times m)$ 的复杂度。

### 2. KMP 算法

* **工作方式**：
    1.  预处理模式串 `P`，生成一个 `next` 数组（部分匹配表）。`next[j]` 存储了 `P[0...j-1]` 这段子串中“最长的相等前后缀”的长度。
    2.  比较 `T[i]` 和 `P[j]`。
    3.  如果 `T[i] != P[j]`（发生失配），**文本串指针 `i` 永不回溯**。
    4.  模式串指针 `j` 根据 `next` 数组智能地移动到 `j = next[j]`。这相当于利用已知信息，跳过了大量不可能匹配成功的位置。
* **时间复杂度**：$O(n + m)$ ( $O(m)$ 预处理 + $O(n)$ 匹配)。
* **优势来源**：KMP 的 `next` 数组就是为了专门高效处理 `BF` 算法的“部分匹配”陷阱。它的性能是稳定的、线性的，并且**与字符集大小无关**。

## 论证：为什么字符集越大，KMP 优势越小？

此问题的关键在于：**KMP 的性能是稳定的，但蛮力算法的“平均性能”会随着字符集增大而大幅变好，逐渐接近 KMP。**

### 1. 场景一：字符集很小

* **例子**：二进制串 `{0, 1}` 或 DNA 序列 `{A, C, G, T}`。
* **分析**：
    * **模式串**：很容易出现 `P = "00010001"` 这样具有大量重复前后缀的模式。
    * **文本串**：很容易出现 `T = "000100010001..."` 这样的重复序列。
    * **结果**：这恰好是蛮力算法（BF）的**最坏情况**，"部分匹配"陷阱会频繁出现，导致 `BF` 算法性能急剧下降到 $O(n \times m)$。
    * **结论**：此时，KMP 算法 $O(n + m)$ 的稳定性优势**非常巨大**。

### 2. 场景二：字符集很大

* **例子**：Unicode（包含数万个字符），甚至只是包含大小写字母、数字和符号的 ASCII 扩展集。
* **分析**：
    * 设字符集大小为 $|\Sigma|$。
    * **模式串**：模式串内部出现“相等前后缀”的概率大大降低。例如 `P = "HelloWorld"`，它的 `next` 数组几乎全是 0。
    * **文本串**：在文本串中任意两个字符匹配的概率很低（约为 $1 / |\Sigma|$）。
    * **结果（对蛮力算法的影响）**：
        * 当 `BF` 算法进行 `T[i]` 和 `P[j]` 的比较时，发生失配的概率非常高。
        * **最关键的是**：失配极大概率发生在 `j = 0` 或 `j = 1` 时，也就是刚开始比较模式串的第 1、2 个字符时。
        * *例子*：在 "ABCDEFGHIJK..." 中查找 "PQRST..."。
        * `BF` 比较 `A` 和 `P`，立即失配。`i` 移动到 `1`，`j` 回到 `0`。
        * `BF` 比较 `B` 和 `P`，立即失配。`i` 移动到 `2`，`j` 回到 `0`。
        * 在这种情况下，`BF` 算法在文本串的每个位置上平均只执行 1 到 2 次比较。其**平均时间复杂度**无限趋近于 $O(n)$。

## 总结

1.  **KMP 的优势**：在于其 $O(n+m)$ 的**最坏情况**时间复杂度，它通过 `next` 数组完美解决了"部分匹配"陷阱。
2.  **蛮力算法的劣势**：在于其 $O(n \times m)$ 的**最坏情况**时间复杂度，它在"部分匹配"时效率极低。
3.  **核心论点**：当**字符集增大**时，"部分匹配"陷阱（例如 "AAAAAB" vs "AAAAAAAAA"）出现的概率**急剧降低**。
4.  **最终推论**：因此，蛮力算法的**平均性能**大幅提升，趋近于 $O(n)$。由于蛮力算法的平均性能变得和 KMP 的性能（$O(n+m)$）在同一数量级，KMP 用来解决最坏情况的 `next` 数组就“英雄无用武之地”了。所以，KMP 相对蛮力算法的优势就越小。



![[Pasted image 20251022133616.png]]

### 2. 理解各条曲线 (算法)

#### 1. KMP (水平线)
* **曲线形态**：一条位于 $O(n + m)$ 的**水平直线**。
* **含义**：KMP 算法的性能**与字符集大小（或 Pr）无关**。无论是大字符集还是小字符集，它的预处理 $O(m)$ 和匹配 $O(n)$ 都是稳定的。
* **特点**：KMP 的优势在于其**稳定的最坏情况保证**。它的“下限”很高（不会太差），但“上限”也不算顶尖（不会有 $O(n/m)$ 的惊喜）。

#### 2. BF (Brute-Force / 蛮力算法)
* **曲线形态**：从左下角（$Pr=0$ 时接近 $O(n)$）急剧上升到右上角（$Pr=1$ 时达到 $O(n \times m)$）。
* **含义**：
    * **Pr $\approx$ 0 (大字符集，图左侧)**：BF 算法性能**非常好**，接近 $O(n)$。因为字符集大，几乎每次都在模式串的第一个字符就失配了，所以文本串的每个位置平均只比较 1-2 次。
    * **Pr $\approx$ 1 (小字符集，图右侧)**：BF 算法性能**急剧恶化**，达到 $O(n \times m)$。这是因为它会陷入“部分匹配”的陷阱（例如在 "AAAAAAAA" 中查找 "AAAAB"），导致指针 `i` 不断回溯。
* **结论**：这完美印证了你上一个问题——**“字符集越大（Pr 越小），KMP 算法和蛮力算法比越没有优势”**。因为在图的左侧，BF 曲线（蛮力）在 KMP 曲线的*下方*，意味着 BF 此时*更快*。

#### 3. BC (Bad Character / 坏字符规则)
* **曲线形态**：类似 BF，但起点更低（$O(n/m)$），终点同样是 $O(n \times m)$。
* **含义**：这是 Boyer-Moore (BM) 算法的启发式规则之一。
    * **Pr $\approx$ 0 (大字符集)**：BC 规则**极其高效**。一次失配可以跳过大量字符（最多 $m$ 个），达到 $O(n/m)$ 的最佳性能。
    * **Pr $\approx$ 1 (小字符集)**：仅靠 BC 规则，在小字符集下同样会失效，退化到 $O(n \times m)$ 的最坏情况。

#### 4. BC+GS (Boyer-Moore / 坏字符 + 好后缀)
* **曲线形态**：从左下角（$O(n/m)$）平缓上升到右侧的 $O(n+m)$。
* **含义**：这是**完整的 Boyer-Moore 算法**。
    * **Pr $\approx$ 0 (大字符集)**：它享受 BC 规则带来的 $O(n/m)$ 最佳性能。
    * **Pr $\approx$ 1 (小字符集)**：当 BC 规则失效时，**GS (好后缀) 规则**开始生效。GS 规则提供了**最坏情况下的性能保证**，使其最差不会超过 $O(n+m)$，和 KMP 持平。
* **结论**：BC+GS (Boyer-Moore) 算法通常是**最快**的。它既有大字符集下的最佳性能 $O(n/m)$，也兼顾了小字符集下的最坏性能 $O(n+m)$。