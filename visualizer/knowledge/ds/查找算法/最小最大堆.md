### 什么是最小最大堆 (Min-Max Heap)？

最小最大堆是一种**双端优先队列**（Double-Ended Priority Queue）。

它和普通堆（最小堆或最大堆）一样，在结构上总是一棵**完全二叉树** (Complete Binary Tree)。

它最大的特点是：**允许你高效地（在 O(1) 时间内）同时获取到最小值和最大值**。

---

### 核心特性：最小-最大层交替

最小最大堆的关键规则是：**树的每一层交替为“最小层” (Min Level) 和“最大层” (Max Level)**。

- **根节点**（第0层）是**最小层**。
    
- **最小层** (Min Level) 上的节点：它的值必须**小于或等于**它的所有后代（子节点、孙节点等）。
    
- **最大层** (Max Level) 上的节点：它的值必须**大于或等于**它的所有后代。
    

这个结构看起来像这样：

- 第 0 层 (Root): **Min** Level
    
- 第 1 层 (Children): **Max** Level
    
- 第 2 层 (Grandchildren): **Min** Level
    
- 第 3 层: **Max** Level
    
- ... 以此类推。
    

### 这种结构带来了什么？

这种交替的层级特性，直接导致了两个重要结果：

1. **最小值：** 永远在**根节点**。
    
    - 因为根节点在最小层，它必须小于等于所有后代，所以它一定是全局最小值。
        
2. **最大值：** 永远在**根节点的子节点中**（即第1层）。
    
    - 因为第1层是最大层，这一层的节点必须大于等于它们各自的所有后代。全局最大值一定在这一层。
        

---

### 关键操作与复杂度

最小最大堆支持的操作与普通堆类似，但插入和删除的逻辑更复杂。

- **`Find-Min()` (查找最小): O(1)**
    
    - 直接返回根节点。
        
- **`Find-Max()` (查找最大): O(1)**
    
    - 比较根节点的两个子节点（如果存在），返回其中较大的那个。
        
- **`Insert(x)` (插入): O(log n)**
    
    - **步骤1：** 将新元素 `x` 放到完全二叉树的末尾（最后一个位置）。
        
    - **步骤2：** 执行 **"上浮 (Bubble-up)"** 操作。这个上浮过程比普通堆复杂，因为它需要同时满足最小层和最大层的约束：
        
        - 首先，它会检查与**父节点**的约束。
            
        - 如果没问题，它会继续检查与**祖父节点**的约束（因为祖父节点和它自己是同类型层，比如同为Min层）。
            
        - 如果发生交换，元素可能会在Min层和Max层之间切换，上浮的比较逻辑（是找更大还是找更小）也会随之改变。
            
- **`Delete-Min()` (删除最小): O(log n)**
    
    - **步骤1：** 移除根节点（即最小值）。
        
    - **步骤2：** 将完全二叉树的**最后一个元素** `L` 移到根节点。
        
    - **步骤3：** 执行 **"下沉 (Trickle-down)"** 操作。这个下沉过程是 `Insert` 的逆操作：
        
        - `L`（现在在根节点，Min层）需要与它的**所有子节点和孙节点**中**最小**的那个进行比较。
            
        - 如果这个最小的元素是一个**孙节点** (`GC`)：则交换 `L` 和 `GC`。`L` 仍然停留在Min层，继续按“Min层”的规则下沉。
            
        - 如果这个最小的元素是一个**子节点** (`C`)：则交换 `L` 和 `C`。`L` 现在到了Max层，需要按“Max层”的规则继续下沉（即和它的后代中_最大_的那个比较）。
            
- **`Delete-Max()` (删除最大): O(log n)**
    
    - 过程与 `Delete-Min` 对称且类似。找到根的子节点中最大的那个，将其移除，用最后一个元素 `L` 替换，然后执行“Max层”的下沉操作。
        

---

### 总结

最小最大堆的核心价值在于它是一个**对称的**数据结构。

- **普通最小堆：** O(1) 找最小，O(log n) 找最大。
    
- **最小最大堆：** **O(1) 找最小，O(1) 找最大**。
    

它用更复杂的 `Insert` 和 `Delete` 逻辑（都是 O(log n)，但常数因子更大），换取了在两个极端（Min 和 Max）都能 O(1) 查找的能力。

你想看一个图解示例，还是想深入了解 `Insert` (插入) 或 `Delete-Min` (删除最小) 操作的具体步骤吗？