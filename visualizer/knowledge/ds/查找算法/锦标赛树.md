# 锦标赛树（Tournament Tree）在查找/优先级队列中的应用
> 主题：本小节围绕“不断找/删最值（min/max）”与“优先级队列”展开，解释锦标赛树（胜者树/败者树）的思想、实现与典型应用。

---

## 1. 核心直觉
- **锦标赛树**把 k 个候选元素两两“比拼”，层层胜出，根节点即全局赢家（最小值或最大值）。
- **胜者树（winner tree）**：每个内部结点存该子树的“胜者”。
- **败者树（loser tree）**：每个内部结点存该子树的“败者”，根部额外记全局胜者；更新时路径上只需与“挑战者”比较，常见于外部排序的 k 路归并。
- 一次“淘汰赛”后，**查询最值 O(1)**，**替换/删除并插入新值 O(log k)**。与堆同阶，但由于**复用历史比较结果**，当“比较代价很高（复杂 key）”时常有更好的常数表现。

---

## 2. 为什么适合“不断找/删最值”
- 典型任务是反复执行：取出最小（或最大）元素 → 用新元素补位 → 再取出最小……  
- 锦标赛树在**每次只重算经过的路径**，其余对局结果沿用。  
- 时间复杂度：
  - 建树：$O(k)$（约 $k-1$ 次比较）
  - 每次 `extract-min` 后 `update`：$O(\log k)$
  - 空间：$O(k)$

---

## 3. 与二叉堆（priority queue）的对比
相同点：都能在 $O(\log k)$ 时间完成插入/删顶，顶元素查询 $O(1)$。

不同点（偏实践层面的取舍）：
- **比较复用**：锦标赛树只在“挑战路径”上比较；堆上滤/下滤每层都要比较两子节点（常数略大）。
- **稳定合并**（k 路归并）：锦标赛树自然携带“来源 run id”，便于**稳定性与哨兵处理**；堆也能做，但写法上锦标赛树更直观。
- **实现与缓存模式**：当 key 计算昂贵或需外存访问时，锦标赛树可减少冗余比较/访问。

---

## 4. 典型应用场景
1) **k 路归并（外部排序）**  
   - 对 k 个已排序“run”，用败者树/胜者树维护各 run 的头元素：每次弹出全局最小并从对应 run 取下一个补位。  
   - 当某个 run 耗尽，用“哨兵值 +∞”补位，直到全部耗尽。  
   - 优点：比较次数少、易稳定合并。

2) **流式 Top-k / 选最值**  
   - 不断到达新元素，用“取顶 + 更新”的方式维护当前最小/最大集。

3) **任务/事件调度**  
   - 以“下次执行时间”为键，取最早事件并更新下一次触发时间。

4) **合并多有序队列**  
   - 如搜索系统将多个倒排段合并输出最小 docID。

---

## 5. 实现要点（胜者树思路）
- 令 **k** 为参与数；取 **base = 最小的 2 的幂 ≥ k**，把叶子定位在 `[base, 2*base)` 的一段连续区间。
- **树节点存的是“叶索引（来源 run id）”**，真正的值放在 `heads[run_id]` 中；比较时用 `heads` 里的当前值。
- **哨兵**：对“无效/耗尽”的 run，令其键为 `+∞`（或对求最大用 `-∞`），使其不再胜出。
- **稳定性**：比较时如 `key(a)==key(b)`，用 `(run_id, 序号)` 作为次关键字即可。

---

## 6. 败者树 vs 胜者树（用哪个？）
- **败者树**更新时仅与沿途败者比较，某些实现中能减少一次比较，外排文献常偏好；
- **胜者树**结构更直观，容易用数组完成“一行代码复用”。两者在复杂度上均为 $O(\log k)$，可按编码偏好选择。

---

## 7. 伪代码（胜者树，维护最小值）
```
build(heads[0..k-1]):
  base ← 1 << ceil_log2(k)
  tree[1 .. 2*base-1]  // 存放“赢家 run_id”，内部结点区间 [1, base-1]，叶子 [base, base+k-1]
  // 初始化：把每个叶子位置写成其 run_id，其余叶子写成 dummy_id 指向 +∞
  for i in 0..base-1:
    leaf_id ← (i < k) ? i : dummy_id
    tree[base + i] ← leaf_id
  // 自底向上“打比赛”：内部结点存左右叶胜者的 run_id
  for p in (base-1) down 到 1:
    L ← tree[2*p]; R ← tree[2*p+1]
    tree[p] ← better(L, R)   // better 比较 heads[L] vs heads[R]

top():
  return tree[1]  // run_id of current global min

update(run_id, new_value):
  heads[run_id] ← new_value
  p ← (base + run_id) / 2
  while p ≥ 1:
    L ← tree[2*p]; R ← tree[2*p+1]
    tree[p] ← better(L, R)
    p ← p / 2

better(a, b):
  // 比较 heads[a] 与 heads[b]，带稳定 tie-break
  // 返回较小者的 run_id（若 a 或 b 为 dummy_id，对应 +∞）
```


---

## 8. 小例子（3 路升序归并）
run0: 1, 4, 9  
run1: 1, 3, 7  
run2: 2, 6, 8  

- 初始建树 → 顶为 (run0, 1) 或 (run1, 1)，按稳定 tie-break 取 run0。  
- 输出 1（来自 run0），run0 补位为 4 → 自底向上更新，新的顶为 (run1, 1)。  
- 输出 1（run1），run1 补位为 3 → 更新，顶为 (run2, 2) 或 (run1, 3)，依次类推……  
- 某 run 耗尽即用 +∞ 哨兵补位，直到全部耗尽。

---

## 9. 复杂度与比较次数
- 建树约比较 $k-1$ 次。
- 每次更新需比较 $⌈\log_2(\text{base})⌉$ 次（常数小，且可复用以往比较结构）。
- 对外部排序，比较代价（含磁盘/反序列化/复杂 key）高时尤其占优。

---

## 10.cpp参考实现（胜者树 + k 路归并）


---

## 11. 在优先级队列中的使用模式
- 若要实现“不断删/找最小值”的 **priority queue**，可直接用锦标赛树包装：
  - `push(x)`：把新值放入某个空 run 或扩容（实践中常用堆；锦标赛树更适合 k 固定的“多源合并”）。
  - `top()` / `pop()`：分别返回/删除全局最小。
- 对“固定 k、每次只替换同一来源”的场景（例如 k 路归并、调度循环），锦标赛树最简洁。

---

## 12. 工程小贴士
- **键提取缓存**：若 key 计算昂贵，提前把 key 存到 `heads`，避免重复计算。
- **稳定性**：用 `(key, run_id, seq)` 做比较三元；`seq` 是该 run 的局部递增计数。
- **缺失/耗尽**：用 `+∞` 哨兵替代；求最大时用 `-∞`。
- **k 非 2 次幂**：用 `base=2^⌈log2 k⌉` 补齐叶子，未用叶子填哨兵。
- **可并行**：底层对局在建树阶段可并行；更新阶段是 $O(\log k)$ 的链式。

---

## 13. 小结
- 锦标赛树是“缓存比较结果”的优先队列结构，特别适合**固定 k、多路数据源**的“持续找/删最值”。
- 在外部排序的 **k 路归并**中尤为常用（经典：**败者树**），在复杂 key、IO 昂贵或需要稳定性的合并中更具优势。
