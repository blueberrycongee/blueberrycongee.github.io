## 三、Leftist Heap (左式堆)

### 1. 动机：高效合并
* **需求**：合并 (Merge) 两个堆 $A$ 和 $B$。
* **完全二叉堆的合并方法**：
    1.  **逐个插入**：从 $B$ 中做 $m$ 次 `delete_max`，再 `insert` 到 $A$ 中。
        * 复杂度：$\mathcal{O}(M \log(N+M))$。
    2.  **打散重建**：将 $A$ 和 $B$ 的元素合并，使用 Floyd 算法重建堆。
        * 复杂度：$\mathcal{O}(N+M)$ (这个效率已相当不错)。
* **新目标**：能否在 $\mathcal{O}(\log N)$ 时间内完成两个堆的合并？

### 2. 左偏堆的核心思想
* **一般堆**：左偏堆**不是**完全二叉堆，通常使用**二叉链表**（指针）存储。
* **合并策略**：统一**沿右侧藤 (Right Spine)** 进行合并。
* **复杂度**：合并操作的复杂度正比于**右侧藤的长度**。
* **关键**：必须约束堆的形态，使得**右侧藤长**始终保持在 $\mathcal{O}(\log N)$。

### 3. NPL (Null Path Length)
* **外部节点 (External Nodes)**：为分析方便，引入外部节点（即 `null` 指针指向的虚拟节点）。
* **NPL 定义**：节点 $x$ 的 NPL 值 $npl(x)$，定义为：
    * $npl(\text{external node}) = 0$
    * $npl(x) = 1 + \min( npl(x.\text{left}), npl(x.\text{right}) )$
* **NPL 的含义**：节点 $x$ 到其后代中**最近的外部节点**的距离。
* **示例**：
    * 一个节点 $x$，左右孩子都是外部节点，则 $npl(x) = 1 + \min(0, 0) = 1$。
    * (※ 讲师示例) 红色节点 2：
        * 左孩子 $npl=1$。
        * 右孩子：其左孩子 $npl=1$，右孩子 $npl=0$ (外部节点)。
        * 右孩子 $npl = 1 + \min(1, 0) = 1$。
        * 红色节点 2 的 $npl = 1 + \min(1, 1) = 2$。

### 4. 左偏堆的定义
左偏堆是满足以下两个性质的二叉树：
1.  **堆序性 (Heap-Order Property)**：(根 $\le$ 左右孩子，或 $\ge$) 堆的本质属性。
2.  **左倾性 (Leftist Property)**：对于**任意**内部节点 $x$，必须满足：
    $$npl(x.\text{left}) \ge npl(x.\text{right})$$

* **推论**：
    * 由于左倾性， $npl(x)$ 的计算被简化为：$npl(x) = 1 + npl(x.\text{right})$。
    * $npl(\text{root})$ 的值**恰好等于**根节点**右侧藤的长度**。

> [!WARNING] 常见误区
> * **问题**：左倾是否意味着“左子堆的规模（节点数）或高度必然大于右子堆”？
> * **答案**：**显然不是。**
> * 左倾性只约束 NPL 值。一个节点的右子堆可能比左子堆更高、节点更多，但 NPL 值（到最近外部节点的距离）一定更小。

### 5. 左偏堆的规模性质

* 一个左偏堆，如果其 $npl(\text{root}) = d$（即右侧藤长为 $d$）：
    * 该堆至少包含 $2^d - 1$ 个**内部节点 (Internal Nodes)**。
    * 该堆至少包含 $2^{d+1} - 1$ 个**节点 (Nodes)**。

> [!IMPORTANT] 核心概念辨析：节点 vs 内部节点
> * 讲师反复强调：在此上下文中，“**节点**”**包含**了“**外部节点**”。
> * “**内部节点**”才对应存储**关键码 (Key)** 的节点。
> * $N_{\text{total}} \ne N_{\text{internal}}$。
> * **推论**：对于一个包含 $N$ 个内部节点的左偏堆，其右侧藤长 $d \le \log(N+1)$。即 $d = \mathcal{O}(\log N)$。
> * 这保证了合并的复杂度。

### 6. 左偏堆的操作 (复杂度均为 $\mathcal{O}(\log N)$)

#### a. 合并 (Merge)
* `Merge(H1, H2)` 是核心操作（以小根堆为例）：
    1.  **确定根**：不妨设 $H1.key \le H2.key$。（若 $H1.key > H2.key$，则交换 $H1, H2$）。
    2.  **递归合并**：$H1$ 的右子堆需要和 $H2$ 合并。
        `H1.right = Merge(H1.right, H2)`
    3.  **维护左倾性**：合并返回后，$H1$ 的右子堆可能变化。检查 $H1$ 的左右孩子 NPL：
        `if (npl(H1.left) < npl(H1.right))`
        `  swap(H1.left, H1.right)`
    4.  **更新 NPL**：`H1.npl = 1 + npl(H1.right)`
    5.  **返回**：`return H1`

#### b. 插入 (Insert)
* 插入一个新值，等价于将原堆与一个**仅含单个内部节点**的新堆进行合并。
* 复杂度：$\mathcal{O}(\log N)$。

#### c. 删除 (Delete Min / Max)
* 删除根节点。
* 剩下**左子堆**和**右子堆**。
* 将这两个子堆进行**合并**。
* 复杂度：$\mathcal{O}(\log N)$。

---

## 四、※ 简要提及与习题选讲

### 1. ※ 提及的跳过内容
* **优先级搜索树 (Priority Search Trees)**：(PPT 88-93页) 课程未展开，且 2016-2020 年未考过。
* **迭代实现**：提及左偏堆合并也有迭代实现方式。

### 2. 习题与考点
* **左偏堆**在历年真题中**经常出现**。

* **Q1 (2014 期末)**：从 2014 个元素中选最大的 5 个，最坏情况比较次数最少？
    * **答案**：A (建最大堆 $\mathcal{O}(N)$，做 5 次 `delete_max` $\mathcal{O}(K \log N)$)。
    * **辨析**：优于 $\mathcal{O}(N \cdot K)$ 的类选择排序方法。Floyd 建堆 (B) 比较次数较多。

* **Q2 (判断)**：胜者树 (Winner Tree) 的根是冠军；败者树 (Loser Tree) 的根是亚军。
    * **答案**：**错误**。
    * **分析**：败者树的根只是在某轮比赛中输给冠军的选手，不一定是全局第二名（亚军）。亚军可能在另一半区，在决赛前就输给了冠军。（如：NBA 东部冠军未必是联盟亚军）。

* **Q3 (判断)**：(※ 即 d-ary 堆分析) 多叉堆的删除操作成本一定高于二叉堆。
    * **答案**：**错误**。
    * **分析**：$d=3$ 时成本更低。

* **Q4 (2019 简答)**：为何用多叉堆优化 PFS？
    * **答案**：见上文“d-ary 堆”章节的“2019年考题” callout。

* **Q5 (判断)**：合并左偏堆 A 和 B 得到 H，H 的右侧链上的节点**未必**都来自 A 或 B 的右侧链。
    * **答案**：**正确**。
    * **分析**：在 `Merge` 过程中，为了维护左倾性（`if npl(L) < npl(R)`），可能会发生**左右子堆交换**。这导致原先在左子堆上的节点（不在右侧链上）被交换到了右侧链上。

* **Q6 (2023 填空)**：在包含 2023 个**节点**的左偏堆中，其**右子堆**最多可能有多少个**节点**？

> [!TIP] 2023 真题解析 (Q6)
> * **前提**：“节点” 包含外部节点。$N_{\text{total}} = 2023$。
> * **结构**：$N_{\text{total}} = 1 (\text{root}) + N_{\text{left}} + N_{\text{right}}$。
> * $N_{\text{left}} + N_{\text{right}} = 2022$。
> * **约束**：$npl(L) \ge npl(R)$。
> * **目标**：最大化 $N_{\text{right}}$。
> * **分析**：要最大化 $N_{\text{right}}$，必须**最小化** $N_{\text{left}}$，同时满足 NPL 约束。
>     1.  **假设 $N_{\text{left}}$ 最小 (Case 1)**：$N_L = 1$（即 $L$ 是一个外部节点）。
>         * $npl(L) = 0$。
>         * 此时 $N_R = 2022 - 1 = 2021$。
>         * $R$ 包含 2021 个节点，它不是外部节点，所以 $npl(R) \ge 1$。
>         * **检查约束**：$npl(L) \ge npl(R) \implies 0 \ge 1$。**此路不通**。
>     2.  **假设 $N_{\text{left}}$ 次小 (Case 2)**：$N_L$ 是最小的*非外部*左偏堆。
>         * $N_L = 3$（1个内部根，2个外部孩子）。
>         * 此时 $npl(L) = 1 + \min(0, 0) = 1$。
>     3.  **计算 $N_{\text{right}}$**：
>         * $N_R = 2022 - 3 = 2019$。
>     4.  **检查约束**：
>         * 我们能否构造一个 $R$ 堆， $N_R = 2019$ 且 $npl(R) \le npl(L)$（即 $npl(R) \le 1$）？
>         * 可以。$npl(R)=1$ 是可能的（例如，一个根，一个 $npl=0$ 的右孩子，一个 $npl \ge 0$ 且含 2015 个节点的左孩子）。
>         * **约束满足**：$npl(L) = 1, npl(R) = 1$。$1 \ge 1$ 成立。
> * **答案**：右子堆最多可能有 **2019** 个节点。